[TOC]

# 特殊类型处理
## 函数
> 实际上克隆函数是没有实际应用场景的，两个对象使用一个在内存中处于同一个地址的函数也是没有任何问题的，以下是lodash对函数的处理：
```
const isFunc = typeof value == 'function'
if (isFunc || !cloneableTags[tag]) {
  return object ? value : {}
}
```

### 方式01
`let newFoo = oldFoo.bind({})`;

特性：
- 引用地址不再相同
- 可以传递参数
- 解决了this指向的问题

缺陷：
- 它不会克隆函数对象的自有属性

### 方式02
```
Function.prototype.clone = function(){
    const cloneObj = this;
    let temp = function () {
        cloneObj.apply(this,arguments)
    };
    for(let key in this){
        if(this.hasOwnProperty(key)){
            temp[key] = this[key]
        }
    }
    return temp;
}
```
优点：
- 解决了方式不克隆对象属性的问题

缺点：
- 每次使用时，它都会嵌套，从而导致功能变慢

### 方法03
```
Function.prototype.clone = function() {
    let cloneObj = this;
    if(this.__isClone) {
      cloneObj = this.__clonedFrom;
    }

    let temp = function() { return cloneObj.apply(this, arguments); };
    for(let key in this) {
        temp[key] = this[key];
    }

    temp.__isClone = true;
    temp.__clonedFrom = cloneObj;

    return temp;
};
```
前一个方法每次使用时，都会嵌套，从而导致功能变慢，使用此方法不会深层嵌套，他始终被称为原始对象

### 方法04
```
function cloneFunction(func) {
    const bodyReg = /(?<={)(.|\n)+(?=})/m;
    const paramReg = /(?<=\().+(?=\)\s+{)/;
    const funcString = func.toString();
    
    if (func.prototype) {
        const param = paramReg.exec(funcString);
        const body = bodyReg.exec(funcString);
        if (body) {
            if (param) {
                const paramArr = param[0].split(',');
                return new Function(...paramArr, body[0]);
            } else {
                return new Function(body[0]);
            }
        } else {
            return null;
        }
    } else {
        return eval(funcString);
    }
}
```
> 使用eval / new函数的不利之处在于，克隆和原始函数将在不同的范围内运行。它不能与使用范围变量的函数一起很好地工作。使用类似绑定的包装的解决方案与范围无关。
