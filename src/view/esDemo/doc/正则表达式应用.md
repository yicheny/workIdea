[TOC]

# 为什么需要正则表达式
在捕获或校验某些模式的字符串时，相比函数正则表达式更加优雅和简洁

# 创建正则表达式
1. 正则字面量方式：`/test/`
2. 创建`RegExp`对象实例:`new RegExp('test')`

# 修饰符
- `i`：忽略大小写
- `g`：查找所有匹配项【默认找到一个匹配项会停止匹配】
- `m`：允许多行匹配
- `y`: 粘连匹配【？？？】
- `u`: 允许使用Unicode点转义符`{\u{...}}`

## 修饰符的使用
- 在字面量的末尾添加修饰符：`/test/ig`
- 作为构造函数的第二个参数：`new RegExp('test','ig)`

# 匹配字符集
> 除了非特殊字符或操作符，字符操作符必须准确出现在表达式中，正则表达式是精准匹配。比如`/test/`只会匹配出连续的`test`字符串

- 有时候我们需要希望匹配一组有限字符集中的字符，比如说：`[abc]`会匹配a、b、c中的任意一项。
- 使用`[^abc]`会匹配a、b、c之外的任意字符
- 对于数字或字母，可以`[a-m]`的方式匹配a到m的任意字符

# 转义
一些特殊字符不能直接放到表达式中，需要通过`\`字符转义

# 或操作符
- `|`:使用`/a|b/`可以匹配a或b

# 起止符号
- `^`：起始
- `$`：结束

# 重复出现
- `?`：0或1次
- `+`：至少1次
- `*`：至少0次【也就是说可以不出现】
- `{a}`：指定重复次数
- `{a,b}`：指定重复的封闭范围
- `{a,}`：指定重复的开放范围

# 预定义符号
预定义符号分两种情况
- 有些希望匹配的内容无法通过字符字面量来表示（回车符，空白符这些）
- 有些常用的字符集【比如字母、数字】

预定义的元字符 | 匹配的字符集 
-- | -- 
\t | 水平制表符 
\b | 空格
\v | 垂直制表符
\r | 回车符
\n | 换行符
\cA:\cZ | 控制字符
\u0000:\uFFFF | 十六进制Unicode码
\x00:\xFF | 十六进制ASCII码
. | 匹配除换行字符（\n、\r、\u2028和\u2019）之外的任意字符
\d | 匹配任意十进制数字，等价`[0-9]`
\D | 匹配十进制数字外的任意字符，等价`[^0-9]`
\w | 匹配任何字母、数字和下划线，等价于`[A-Za-z0-9_]`
\W | 匹配字母、数字和下划线外的任意字符，等价于`[^A-Za-z0-9_]`
\s | 匹配任意空白字符（包括空格、制表符、换页符等）
\S | 匹配任意空白字符外的任意字符
\b | 匹配单词边界
\B | 匹配非单词边界（单词内部）

# 分组
使用`/(ab)+/`可以匹配1或多个连续的ab

# 反向引用
反向引用可引用正则中定义的捕获。例如：`/<(\w+)>(.+)<\/\1>/`可以捕获`<h1>标题</h1>`这样的元素。

反向引用分组中捕获的内容，使用反斜线加上数字表示引用，该数字从1开始，第一个分组捕获的为\1，第二个为\2，以此类推