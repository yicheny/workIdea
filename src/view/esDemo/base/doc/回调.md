[TOC]

# 1. 回调的定义
首先，什么是回调？

是指通过函数参数传递到其它代码的，某一块可执行代码的引用。

有些人将其理解为是在事件循环结束后回过去调用的函数，回调是异步的最基础解决方式。

的确，回调可以用于解决异步，但并不意味着回调只能用于异步，这是两回事，回调实际上还牵涉到JS的另一个重要知识，是闭包，或者说作用域。

只要使用回调函数，就必然产生了闭包，闭包是当函数在其所定义的作用域外部被调用时产生的。

我认为准确一点的说法是我们将函数作为参数传递给另一个函数在其内部调用。

函数是立刻执行还是在将来执行都不影响其作为回调函数的事实，关键是，一旦在未来调用，分析代码的执行顺序就会变得麻烦了。

[参考资料_维基百科](https://zh.wikipedia.org/wiki/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0)

# 2. 回调的弊端
在ES6中我们得到新的异步解决方案Promise，那么为什么我们需要新的异步解决方案，callback存在哪些问题？Promise解决这些痛点了吗？

## 其一：不符合人类思考方式
### 回调示例V1_同步
来一个简单的例子：
```
//注意，这里的print并不是一个异步函数
function print(str,callback) {
    console.log(str);
    callback && callback()
}

print('A',function () {
    print('B',function () {
        print('C',function () {
            print('D')
        });
        print('E')
    })
});

print('F');
```
这里代码的执行顺序是ABCDEF，注意，这里虽然使用了回调，但是并不是作为异步使用的。

有一件事，我认为新手开发者需要注意到，那就是回调的确是可以作为异步解决方案，但是使用回调并不一定就用于异步，这是两回事，不要一看到回调就以为发生了异步，要仔细观察和分析。

### 回调示例V2_异步
改写刚刚的`print`函数，使其成为一个异步函数：
```
//print是一个异步函数，一部分代码现在执行，一部分代码通过回调在未来执行
function print(str,callback) {
    console.log(str);
    setTimeout(()=>{
         callback && callback()
    },1000);
}
```
现在执行刚刚的代码，发现打印顺序变成了AFBCED，这就是异步时所面对的状况。

最大的痛点在于这段代码不符合人类的思考习惯，即便是有经验的熟知JS执行规则的程序员分析这段代码的执行顺序时也会感到厌恶。

也许将函数打印的字母改为真正执行的顺序看起来会舒服一些？

### 回调示例V3_顺序调整
```
print('A',function () {
    print('C',function () {
        print('D',function () {
            print('F')
        });
        print('E')
    })
});

print('B');
```
ok，还是之前的异步代码，打印结果变成了ABCDEF，现在我们可以很舒服的查看执行顺序了。

不过，还是存在一个问题，每次查看代码时我们还是得不停得上下移动切换到不同的代码块中，这里代码量少可能不太明显。

实际开发中如果使用回调，可能有几十上百行的代码需要来回修改测试，是很让人痛苦的，而且也容易出错。

除此之外，还有一个更加危险的可能，你注意到了吗？在刚刚的例子里，我所使用的函数要么都是同步，要么都是异步，所以分析起来可能简单一些，然而实际开发中，同步和异步函数可能是混合使用的，分析起来会更为麻烦。

### 回调示例V4_同异混用
```
//同步函数
function printSync(str,callback) {
    console.log(str);
    callback && callback();
}
//异步函数
function print(str,callback) {
    console.log(str);
    setTimeout(()=>{
         callback && callback()
    },1000);
}

printSync('A',function () {
    print('B',function () {
        printSync('C',function () {
            print('D')
        });
        print('E')
    })
});

print('F');
```
现在的打印顺序变成了ABFCDE，是不是感觉分析顺序变得更麻烦了？

到了这一步，你应该可以初步感受到过去JS开发者所感受到的痛苦了。

有人可能认为是这种嵌套/缩进的形式导致代码难以分析，然而不是，我们将示例V2的代码改写一下：

### 回调示例V5_形式调整
```
function print(str,callback) {
    console.log(str);
    setTimeout(()=>{
         callback && callback()
    },1000);
}

function printA() {
    print('A',printB);
}
function printB() {
    print('B',printC);
}
function printC() {
    print('C',printD);
    print('E')
}
function printD() {
    print('D')
}

printA();
print('F');
```
打印结果是依旧是AFBCED不变，然而分析起来并没有变得简单，分析的过程中还是得不停的在不同的代码中跳来跳去。

目前这种情况在真实开发中已经算是简化版本了，不仅是同异步代码混合的问题，这里只有一个回调continuation，如果有更多个回调……又或者回调内部存在gate【开】或latch【关】的并行回调分支……问题会更加复杂，更加难以分析
> gate或latch的并行回调，简单来说就是存在两个或更多虚拟进程时，如果进程之间存在交互，我们需要通过gate或latch进行协调控制

到了这里，我们可以得出结论：**回调最大的缺陷之一在于它在代码中表达异步的方式与人类思考方式不一致，需要花费努力才能理解，至于形式则只是细枝末节**。

## 其二：控制反转
```
console.log('A');

ajax(url,function(){
    console.log('C');
});

console.log('B');
```
`console.log('A')`与`console.log('B')`是在现在执行的代码，在JS主程序控制之下，而`console.log('C')`会被延迟到将来执行，并且是在第三方（`ajax`函数）的控制下。

有些人可能没有在意过控制权切换的问题，实际上这是回调驱动设计一个非常严重的问题，有些时候控制权被移交的API来自于第三方库或工具，回调脱离了开发者的直接控制。

将自己程序的一部分执行控制交给第三方，被称作**控制反转**

### 控制反转导致的信任问题
举一个例子
```
function pay(id){
    console.log('支付者id',id)
    console.log('每执行这个函数，都会进行一次支付')
};

ajax(url,pay);//这里的ajax来自第三方库
```
想象一下，如果这个第三库的某些错误提交，导致这个回调执行时会以开发者预期之外的情况执行，比如说：
- 执行多次
- 不执行
- 丢失报错信息
- 没有正常传递参数给回调
- 执行时机过晚
- 执行时机过早
......

一旦出现问题，就很麻烦，等待第三方修复？如果是不紧急的bug这么做是可行的，联系第三方开发者，等待修复。

不过有很多时候导致你难以等待修复，或者根本没有修复时，你必须自己去修复这些问题。

这种时候，才是真正体现“回调地狱”的时刻，首先，不要去改动第三方的代码，这非常危险。我们可以采取一个补救性或者说防御性的措施，针对可能存在的问题写一个检查函数。

然而，如此一来，为了规避回调带来的这些风险，我们不得不开发出一整套检查的机制，这造成了很大的开发负担，其开发成本甚至可能高于本身的业务开发成本，原本这是不应该存在的。

信任问题不仅会出现在第三方，即便是自己开发的程序也存在信任问题，只要使用回调，控制反转的问题就会存在。

如果你的代码中使用了回调【不限于第三方】，并且没有采取某种逻辑来解决控制反转带来的问题，可以说你的代码中已经有了bug。即使尚未出现问题，隐藏的bug也是bug
> 这句话出自《你不知道的JS中卷》，听起来有点玄

### 控制反转的补救方案
回调设计存在一些变体，用以解决之前存在的一部分信任问题。

这种尝试从回调模式内部挽救的想法是勇敢的，然而注定是失败的。

下面举几个方案。

#### 方案1：分离回调
有些API提供了回调分离，一个用于成功通知，一个用于失败通知【通常此回调可选】
```
function success(data){
    console.log(data);
};

function failure(err){
    console.log(err);
};

ajax(url,success,failure);
```
JS存储机制之一的`indexedDB`提供的API就是这种机制，另外Promise API也是采取的这种分离回调机制。

#### 方案2：error-first
> 也被称作Node风格，因为几乎所有NodeJS API都采用这种风格

error-first风格下，回调的第一个参数用于传递错误对象，如果回调成功则第一个参数会置假，后续参数为成功数据。
```
function reponse(err,data){
    if(err){
        console.log(err);
    }
    else{
        console.log(data);
    }
}

ajax(url,reponse);
```

这两种方案都有助于获取错误信息并对不同的情况进行相应的处理，然而，有些信任问题并没有得到解决，并且带来了一些新的问题。

新的问题在于，现在每次设置回调，都需要考虑成功或失败的结果，它带来了新的模式，然而这个模式更加冗长和模式化，复用性却不高，每次使用回调都需要如此去写。

而信任问题，比如重复调用，晚调用，早调用，不调用的问题依旧没有得到解决。

在之前的例子里，我们知道回调可以同步调用也可以异步调用，推荐的做法是：**永远异步调用回调**，这是一条编程准则，否则，因回调造成的bug将极难追踪
> 小知识：在一部分开发者中，回调的这种同/异步混用的情况被称作恶魔Zalgo，用于描述其恐怖。

### 开发者对信任问题的修复
...待补充

## 回调缺点总结
1. 大脑对事情的处理是线性的、阻塞的、单线程的，而回调表达异步流的方式是非线性的、非顺序的，这使得正确推导代码的难度很大。
> 难以理解的代码是坏代码，会导致bug
2. 回调会受到控制反转的影响，控制权转移会带来一系列的问题。
> 我们可以创造一些特定逻辑解决信任问题，首先有较大的开发难度，其次可能会产生更笨重和难以维护的代码

基于以上两点，我们需要新的异步机制，一方面要更符合人类的思考模式，另一方面需要解决信任问题