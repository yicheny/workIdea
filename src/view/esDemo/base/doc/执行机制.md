[TOC]

# 异步编程
一句话描述异步编程：表达和控制持续一段时间的程序行为。

这里持续一段时间并不是指程序本身耗费的时间【因为即便是`console.log(1)`这样简单的代码也会耗费时间】，这里是指存在**等待时间**的程序。

什么是等待时间？，如果一段代码一部分在现在执行，一部分在未来执行，现在与未来的这段时间间隙我称作等待时间。

如果没有这段间隙，那么就没有现在与未来之分，也就没有异步编程。

异步编程的概念正是源于等待时间的存在，等待时间区分了现在与未来，控制和表达现在和未来 正是异步编程的最佳表述。

基于此表述，我们知道存在等待时间的场景需要异步编程，比如等待用户输入、通过网络请求数据、从数据库或文件系统请求数据、固定时间执行重复任务【如动画】，等待时间可能固定或不固定，无论如何，存在等待时间，就需要使用异步编程进行控制。

异步编程简单来说就是通过一些技术手段【回调、定时器、promise等】，控制代码在未来的指定时间【等待时间之后】执行。

## 1.JS运作模式
异步编程最常见的一种状况是：程序中将来执行的部分不是在现在执行的部分结束后立即执行的.
```
let data = ajax(url);//ajax是某个ajax请求方法，url代表接口

console.log(data);//打印出来不是请求结果
```

常规的操作是这样的，利用回调进行异步编程：
```
ajax(url,(res)=>{
    consolo.log(res);//成功打印结果
})
```

对于一些新手而言，这种写法可能不如前一种写法好理解，他们或许希望获取响应数据后再继续下面的代码。

这种想法从技术上可以实现，而且实际上原生`XMLHttpRequest`是支持同步请求的，不过现在浏览器出于对用户体验的负面影响而被弃用了。

同步请求技术为什么会被弃用？这种做法会锁定页面UI，并阻塞所有交互，相当于卡死状态，所以绝对绝对不要使用同步请求。

可能有人会认为`async await`是同步请求，实际上并不是，`async await`是同步写法的异步代码【通俗来说就是形式上是同步的写法，本质上还是异步执行】。以下是一个简单的例子：

## 2.async await演示
```
    const axios = require('axios');//需要安装并引入axios库
    
    async function request() {
        const data = await api();
        console.log('data',data);
    }

    function api() {
        const url = 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/abs';
        return axios.get(url)
    }

    request();
    console.log(18);
```
执行这段代码，发现是先打印18，再打印data【此时已拿到响应数据】。

关于`async await`这里暂不详细介绍。

## 3.异步控制台
关于控制台的一些特性在调试时可能需要注意下，console.*并不属于ES规范，它们由宿主环境决定。

对于部分浏览器在一些情况下，console.log(...)不会将传入的内容立刻输入，它输出的可能是最终改变的结果。出现这种情况的主要原因是，I/O是非常低速的阻塞部分，所以浏览器会后台异步处理控制台I/O，这么做可以提高性能，相对于直接打印的结果可能会出现混淆。

```
    const obj = {
        aaaaaaaaaaaaaaaaaaaaaaa:0,
        bbbbbbbbbbbbbbbbbbbbbbb:0,
        ccccccccccccccccccccccc:0,
        eeeeeeeeeeeeeeeeeeeeeee:0,
        fffffffffffffffffffffff:0,
        name:0,
    };

    console.log(obj);

    obj.name++;
```
执行这段代码，发现打印的`obj`其`name`已经改变了。

一般推荐两种方案进行即时输出：
1. `debugger` 打断点
2. `JSON.stringify()` 把对象序列化到一个字符串中，以强制执行一次“快照”

# 事件循环机制
首先需要明确一点，JS是单线程执行，同一时间内只能做一件事。

JS的宿主环境会实现一个持续的循环，最开始，循环会将所有同步代码执行完，然后，再执行异步代码。
> 也可以认为全局同步代码是事件队列中的第一个代码块，这样JS执行本身就不存在异步这一概念了，宿主环境只是在每次循环中按顺序取出事件队列的代码块执行而已。 <br/>

异步代码如何执行，JS事件使用的是队列机制，触发一个注册的事件，就将这个事件的回调函数放到事件队列里，每一次循环，宿主环境都会区查询队列里有没有待执行的函数，如果有则依次执行。

定时器也是队列机制，设定一个定时器，定时器到时后会将回调放入队列，然后事件队列继续在每一次循环中按顺序执行。

异步就是这么回事，在我们指定的时机对应的代码块加入队列中，宿主环境会按顺序摘出里面的代码块并执行。

到这里，我们可以明白为什么定时器会执行存在时间误差了，定时器在到达时间后会立刻将回调函数加入队列不错，却不能保证此时队列没有其他代码块，代码执行是需要时间的。
> 注意：JS没有插队的机制，只能按部就班的进行排队【加入队列】

JS单线程中并没有时间/异步的概念，宿主环境只是在每次循环中按顺序取出事件队列的代码块执行而已

**JS异步编程真正控制的，是加入事件队列的时机，而非执行的时机**。

## 1.完整运行
因为JS的单线程特性，JS的函数具有**原子性**，函数一旦开始执行，直到这个函数所有代码执行完成前不会去执行其他函数，这被称为**完整运行**特性。
> 例外是es6引入的生成器，它不具有完整运行特性。

这个特性使得JS的更加可控，如果两个不同的函数其内代码可以交替运行在环境中，并且操作的是同一块内存，那么结果将难以预料。

JS的输出结果不可控一般出于函数执行顺序不同，关键原因在于异步。
> 注意：并非所有的函数执行顺序都会造成结果不可控，两者需要操作同一个值时才会对结果造成影响。

这种函数顺序的不确定性被称作**竞态条件**【race condition】。

见示例：
```
let a = 3;

function foo(){
    a = a * 3;
}

function bar(){
    a = a + 3
}

ajax(url,foo);//ajax是异步请求，请求结束后执行回调
ajax(url2,bar);

console.log(a); // 12? 18?
```
如果第一个请求先完成，则先执行`foo`,再执行`bar`,结果是12。

如果第二个请求先完成，则先执行`bar`,再执行`foo`,结果是18。

函数执行顺序不同导致结果不同，这是竞态条件的体现。

JS中会导致这种状况出现的只有异步编程，所以掌握了异步编程，从某种方面而言就等同掌握了函数执行的规则。

## 2.并发
现在假设有一个新闻网站，用户每次向下滚动都会触发新的请求，并根据响应的内容进行展示。

现在的情况是，在发送请求之后，即使没有获得响应，用户依旧可以进行滚动发送新的请求。你会发现，网站这个时候有至少两个**进程**在运行，一个在发送请求，一个对响应内容进行展示。

两个或多个独立**进程**同时运行（是在同一时段运行，而非同一时刻运行），这种情况被称作**并发**，不管组成它们的单个运算是否并行执行（在独立的处理器或处理器核心上同时执行），可以将并发看作任务级【进程】的并行，与运算级【线程】的并行有所区分。
> 注：JS的进程并非计算机科学意义上真正的操作系统级进程，而是虚拟进程，或者说任务，表示一个逻辑上相关的运算序列。<br/>
> 进程为一系列的事件/运算，在进程里事件的顺序是确定的

现在回到假设的网站，让我们看看两个进程在做什么：
```
进程1：
发送请求1
发送请求2
发送请求3
发送请求4

进程2：
响应请求1
响应请求2
响应请求3
响应请求4
```

我们知道JS一次只能处理一个事件，那么进程级的并行是如何进行的呢？下面，让我说一个故事。

### 教学小故事V1
在幻想的世界里，有一所JS执行学校，校长的名字是“执行栈”，这个学校有很多学生，分别是事件1，事件2，事件3......

最开始的时候，只有校长一个人，校长负责全校所有学生，他细致耐心一步步教导学生进行学习，教学完成之后就送学生外出工作。不过显而易见，这种模式存在一个问题，校长只有一个人，并且一次只能教导一个人，而学生可能会有很多，学生数量很多的情况下，效率是非常低下的。

校长的工作流程是这样的：
```
教导事件1
事件1学习完成，送出
教导事件2
事件2学习完成，送出
教导事件3
事件3学习完成，送出
教导事件4
事件4学习完成，送出
教导事件5
事件5学习完成，送出
教导事件6
事件6学习完成，送出
```
假设校长教导一个学生需要花费10天，送出一个学生需要1天，那么完成7个学生的教导和送出所需要花费的事件是66天

也许校长应该一次教导很多个学生？然而问题是每个学生需要学习的内容都不一样：写作、音乐、计算机、缝纫、杀猪、驾驶......教导内容五花八门多种多样，这使得一次教导多个学生的想法成为了奢想。

不过聪明的校长还是想到了办法，他找了几个老师，他将学生根据学习的内容分配给不同的老师，由每个老师教学完成之后学生到校长这里进行汇报，校长将学习完成的学生送出工作。

现在的流程大概是这样的：
```
//这是校长的工作部分
事件1 分配给教师A
事件2 分配给教师A
事件3 分配给教师B
事件4 分配给教师B
事件5 分配给教师B
事件6 分配给教师A

事件1学习完成 送出
事件3学习完成 送出
事件6学习完成 送出
事件2学习完成 送出
事件4学习完成 送出
事件5学习完成 送出

//这是教师A的工作部分
教导事件1
教导事件2
教导事件6

//这是教师B的工作部分
教导事件3
教导事件4
教导事件5
```
描述起来感觉似乎内容更多了一些，然而实际执行的效率却高了很多，因为分配所花费的时间是远低于教导的时间的，我们假设校长分配一个学生需要花费1天时间，老师教导的效率和校长的一样，10天一个学生，送出的时间不变。

天数统计：
```
校长：6+6=12
教师A：3*10=30
教师B：3*10=30
```
这样子，学院从教导6名学生出校的时间花费大概在31天左右【因为从分配之后老师就立刻教导了，而不是等待所有人完成之后再进行教导，送出也是同理，一旦有学生完成则立刻送出】

对比下之前的方案：
1. 执行效率提升【完成时间减短】
2. 花费更多的资源【管理和老师两方面】

有一件事需要意识到，管理本身是会降低效率的，大多数情况下管理是可以提升性能的，但管理也是支出的一部分，从这个例子来说，如果只有一个学生，校长自己教导+送出的时间是11天，交给老师教导+送出的时间是12天，增加支出的同时却降低了效率。

这种情况被称作负优化，平时写代码时需要注意下，很多时候一不注意就会将优化做成负优化导致性能降低。

### 教学小故事V1.1
刚刚的故事和真实的进程有一点不同，在于顺序，真实的进程中不能预测每个运算/事件所花费的事件，存在两个以上的进程时，事件的顺序就难以确定了。

还是幻想世界，现在每个