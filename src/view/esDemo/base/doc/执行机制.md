[TOC]

# 异步编程
一句话描述异步编程：表达和控制持续一段时间的程序行为。

这里持续一段时间并不是指程序本身耗费的时间【因为即便是`console.log(1)`这样简单的代码也会耗费时间】，这里是指存在**等待时间**的程序。

什么是等待时间？，如果一段代码一部分在现在执行，一部分在未来执行，现在与未来的这段时间间隙我称作等待时间。

如果没有这段间隙，那么就没有现在与未来之分，也就没有异步编程。

异步编程的概念正是源于等待时间的存在，等待时间区分了现在与未来，控制和表达现在和未来 正是异步编程的最佳表述。

基于此表述，我们知道存在等待时间的场景需要异步编程，比如等待用户输入、通过网络请求数据、从数据库或文件系统请求数据、固定时间执行重复任务【如动画】，等待时间可能固定或不固定，无论如何，存在等待时间，就需要使用异步编程进行控制。

异步编程简单来说就是通过一些技术手段【回调、定时器、promise等】，控制代码在未来的指定时间【等待时间之后】执行。

## 1.JS运作模式
异步编程最常见的一种状况是：程序中将来执行的部分不是在现在执行的部分结束后立即执行的.
```
let data = ajax(url);//ajax是某个ajax请求方法，url代表接口

console.log(data);//打印出来不是请求结果
```

常规的操作是这样的，利用回调进行异步编程：
```
ajax(url,(res)=>{
    consolo.log(res);//成功打印结果
})
```

对于一些新手而言，这种写法可能不如前一种写法好理解，他们或许希望获取响应数据后再继续下面的代码。

这种想法从技术上可以实现，而且实际上原生`XMLHttpRequest`是支持同步请求的，不过现在浏览器出于对用户体验的负面影响而被弃用了。

同步请求技术为什么会被弃用？这种做法会锁定页面UI，并阻塞所有交互，相当于卡死状态，所以绝对绝对不要使用同步请求。

可能有人会认为`async await`是同步请求，实际上并不是，`async await`是同步写法的异步代码【通俗来说就是形式上是同步的写法，本质上还是异步执行】。以下是一个简单的例子：

## 2.async await演示
```
    const axios = require('axios');//需要安装并引入axios库
    
    async function request() {
        const data = await api();
        console.log('data',data);
    }

    function api() {
        const url = 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/abs';
        return axios.get(url)
    }

    request();
    console.log(18);
```
执行这段代码，发现是先打印18，再打印data【此时已拿到响应数据】。

关于`async await`这里暂不详细介绍。

## 3.异步控制台
关于控制台的一些特性在调试时可能需要注意下，console.*并不属于ES规范，它们由宿主环境决定。

对于部分浏览器在一些情况下，console.log(...)不会将传入的内容立刻输入，它输出的可能是最终改变的结果。出现这种情况的主要原因是，I/O是非常低速的阻塞部分，所以浏览器会后台异步处理控制台I/O，这么做可以提高性能，相对于直接打印的结果可能会出现混淆。

```
    const obj = {
        aaaaaaaaaaaaaaaaaaaaaaa:0,
        bbbbbbbbbbbbbbbbbbbbbbb:0,
        ccccccccccccccccccccccc:0,
        eeeeeeeeeeeeeeeeeeeeeee:0,
        fffffffffffffffffffffff:0,
        name:0,
    };

    console.log(obj);

    obj.name++;
```
执行这段代码，发现打印的`obj`其`name`已经改变了。

一般推荐两种方案进行即时输出：
1. `debugger` 打断点
2. `JSON.stringify()` 把对象序列化到一个字符串中，以强制执行一次“快照”

# 事件循环机制
首先需要明确一点，JS是单线程执行，同一时间内只能做一件事。

JS的宿主环境会实现一个持续的循环，最开始，循环会将所有同步代码执行完，然后，再执行异步代码。
> 也可以认为全局同步代码是事件队列中的第一个代码块，这样JS执行本身就不存在异步这一概念了，宿主环境只是在每次循环中按顺序取出事件队列的代码块执行而已。 <br/>

异步代码如何执行，JS事件使用的是队列机制，触发一个注册的事件，就将这个事件的回调函数放到事件队列里，每一次循环，宿主环境都会区查询队列里有没有待执行的函数，如果有则依次执行。

定时器也是队列机制，设定一个定时器，定时器到时后会将回调放入队列，然后事件队列继续在每一次循环中按顺序执行。

异步就是这么回事，在我们指定的时机对应的代码块加入队列中，宿主环境会按顺序摘出里面的代码块并执行。

到这里，我们可以明白为什么定时器会执行存在时间误差了，定时器在到达时间后会立刻将回调函数加入队列不错，却不能保证此时队列没有其他代码块，代码执行是需要时间的。
> 注意：JS没有插队的机制，只能按部就班的进行排队【加入队列】

JS单线程中并没有时间/异步的概念，宿主环境只是在每次循环中按顺序取出事件队列的代码块执行而已

**JS异步编程真正控制的，是加入事件队列的时机，而非执行的时机**。

## 1.完整运行
因为JS的单线程特性，JS的函数具有**原子性**，函数一旦开始执行，直到这个函数所有代码执行完成前不会去执行其他函数，这被称为**完整运行**特性。
> 例外是es6引入的生成器，它不具有完整运行特性。

这个特性使得JS的更加可控，如果两个不同的函数其内代码可以交替运行在环境中，并且操作的是同一块内存，那么结果将难以预料。

JS的输出结果不可控一般出于函数执行顺序不同，关键原因在于异步。
> 注意：并非所有的函数执行顺序都会造成结果不可控，两者需要操作同一个值时才会对结果造成影响。

这种函数顺序的不确定性被称作**竞态条件**【race condition】。

见示例：
```
let a = 3;

function foo(){
    a = a * 3;
}

function bar(){
    a = a + 3
}

ajax(url,foo);//ajax是异步请求，请求结束后执行回调
ajax(url2,bar);

console.log(a); // 12? 18?
```
如果第一个请求先完成，则先执行`foo`,再执行`bar`,结果是12。

如果第二个请求先完成，则先执行`bar`,再执行`foo`,结果是18。

函数执行顺序不同导致结果不同，这是竞态条件的体现。

JS中会导致这种状况出现的只有异步编程，所以掌握了异步编程，从某种方面而言就等同掌握了函数执行的规则。

## 2.并发
现在假设有一个新闻网站，用户每次向下滚动都会触发新的请求，并根据响应的内容进行展示。

现在的情况是，在发送请求之后，即使没有获得响应，用户依旧可以进行滚动发送新的请求。你会发现，网站这个时候有至少两个**进程**在运行，一个在发送请求，一个对响应内容进行展示。

两个或多个独立**进程**同时运行（是在同一时段运行，而非同一时刻运行），这种情况被称作**并发**，不管组成它们的单个运算是否并行执行（在独立的处理器或处理器核心上同时执行），可以将并发看作任务级【进程】的并行，与运算级【线程】的并行有所区分。
> 注：JS的进程并非计算机科学意义上真正的操作系统级进程，而是虚拟进程，或者说任务，表示一个逻辑上相关的运算序列。<br/>
> 进程为一系列的事件/运算，在进程里事件的顺序是确定的

现在回到假设的网站，让我们看看两个进程在做什么：
```
进程1：
发送请求1
发送请求2
发送请求3
发送请求4

进程2：
响应请求1
响应请求2
响应请求3
响应请求4
```

我们知道JS一次只能处理一个事件，那么进程级的并行是如何进行的呢？下面，让我说一个故事。

### 教学小故事
> 故事待优化

在幻想的世界中，有一所JS学院，校长的名字叫做执行栈，学校里有很多学生，分别叫做事件1，事件2，事件3......

校长负责教导每个学生学习，直到完全教会一个学生后，再去教导下一个学生，教学内容五花八门：屠宰、烹饪、裁缝等等

校长教学的流程大概是这样的：
```
教导事件1
教导事件2
教导事件3
教导事件4
教导事件5
教导事件6
```
可以看到，校长这样做实在是很没有效率，教学速度很慢，校长想加快对学生的教学速度，有没有什么好办法呢？

想法1：一次教导几个学生

很明显这个想法是不行的，学生学习的内容是不同的，不能和现实世界一样采取一个老师教导多个学生的做法

想法2：找几个老师帮助教导学生

很可惜，在其他编程语言中，这个想法是可行的，开启线程或进程是可以做到的，而且确实可以提升效率。但是我们知道JS是单线程语言，它是不能开启线程或进程的。

不过，天无绝人之路，JS是可以开启虚拟进程的，这同样是可行的，第三个想法就是关于虚拟进程。

想法3：一心多用教学
所谓虚拟进程就是身为单线程的校长将自己的思维分成几部分，每个部分处理对应的事件序列，执行的时候还是一件事一件事的执行。

这种做法似乎有些傻？其实是有意义的，因为有些时候，教导【执行】的过程中存在时间空隙，比如说去请求一个接口，接口返回是需要一定时间的，而在这段时间里面其实是可以利用起来去处理其他一些事情的，如此一来执行效率就得到了提高。

不仅如此，还有一点需要关注的是如果我们在等待的期间什么也不能做，这是非常糟糕的，不仅是效率问题，是用户体验，因为JS是单线程机制，一旦某个事件将执行栈霸占了，其他事件就不能被执行了，对于一些存在等待事件或者本身执行事件较长的事件我们需要利用虚拟进程，是非常有意义的【在接下来，你会看到我们是如何利用虚拟进程解决执行栈被霸占的问题的】

感觉JS里的这个虚拟进程和协程概念有点像，简单提一下协程

### 题外：协程
协程，又称微线程、纤程，协程具有并发性，不具有并行性

子程序，或者说函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。

所以子程序是通过栈实现的，一个线程就是执行一个子程序。

子程序调用总是一个入口，一次返回，调用顺序是明确的。

协程的调用和子程序不同，协程是特殊的子程序，在执行过程，子程序内部可中断，转而执行别的子程序，在适当的时候再返回接着执行。

协程的优势有哪些？
1. 执行效率上，协程是由程序自身控制的，没有切换线程的开销，线程数越多，协程的性能优势越明显【管理线程本身也是需要耗费性能的】
2. 只有一个线程，不存在同时写一块内存的冲突，不需要多线程的锁机制【注意，虽然不存在冲突，有些子程序之间可能存在竞态条件，此时需要关注顺序通过程序控制，例如promise对象的race和all方法就对此进行了一些处理，如果子程序之间是非交互关系则无需关注】

es6提供的生成器函数可以实现协程机制【更严谨的说法是半协程】

生成器与协程相同点：都可以yield多次，挂起自身的执行，并允许在多个入口点重新进入。

生成器与协程差异点：协程有能力控制在它让位后哪个协程接续它执行，生成器不能，生成器只能将控制权转交给调用生成器的调用者，在生成器的yield语句中不指定要跳转到的协程，而是向父例程传递返回值。
> 例程是某个系统对外提供的功能接口或服务的集合，比如操作系统的API、服务等

[协程参考资料_维基百科](https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B)
[协程参考资料_廖雪峰](https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272)

### 并发引起的顺序问题
回到最初的网站，它现在有两个进程，一个用于发送请求，一个用于响应请求，我们知道，JS是单线程机制，同一时刻它只会执行一件事

请求和响应在执行栈的实际执行顺序可能是这样的：
```
scroll,发送请求1 
scroll,发送请求2 
响应请求1 
scroll,发送请求3
scroll,发送请求4 
响应请求3 ---响应的顺序并不一定和请求的顺序一致
响应请求4
响应请求2
```
这里响应的顺序可能是混乱的，不过导致这一点的不是进程的问题，而是异步，因为没办法预测响应的时间。

### 非交互
多个虚拟进程在一个程序内并发交替运行其步骤时，这些事件如果完全不相关，那么乱序时可以接受的，这被称作**非交互**。

```
const res = {}

function bar(result){
    res.bar = result;
}
function foo(result){
    res.foo = result;
}

ajax(url1,bar);
ajax(url2,foo);
```
在这段代码里，先响应url1还是url2对结果没有任何影响，它们是独立运行的，不存在竞态条件bug
 
### 交互
不过很多情况下，虚拟进程间需要进行交互，通过DOM或者作用域进行交互。【内存与UI】

一旦进程间存在交互，我们就需要对交互进行协调以避免竞态条件的出现。

下面是一个简单的例子：
```
const res = [];

function response(result){
    res.push(result)
}

ajax(url1,response);
ajax(url2,response);
```
url1和url2的响应顺序会影响存放在res数组里的顺序，如果我们希望res按照发送的顺序进行存放，那么就会存在问题。

不过这个问题很容易解决：
```
const res = [];

//这里也可以不写成多个函数，通过if进行条件控制
function response1(data){
    res[0]===data;
}
function response2(data){
    res[1]===data;
}

ajax(url1,response1);
ajax(url2,response2);
```
除了这种情况，有些情况下我们可能需要所有结果都返回才执行，有些情况下我们只对第一个结果进行处理，诸如此类，都需要进行协调控制，这里就不一一介绍了，关键是记住如果进程间存在交互就需要进行协调。

### 协作
并发协作，其目的是取得一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他进程有机会进入事件队列中运行。

示例如下：
```
let res = [];

function response(data){
    return data.map((el,i)=>el*i+99*i-el*11);//复杂运算
}

axios.get('').then(res=>{
    console.time('axios');
    const mockData = Array(3000000).fill(1000);//数组内数字过大会造成卡死现象，建议配合console.time逐步加大
    response(mockData);
    console.timeEnd('axios');
});
```
这段代码的问题在于data数据量太大了，三百万数组项的复杂运算足以造成上千毫秒的阻塞【这也取决于计算机的性能】，在阻塞的这段过程中无法再执行任何事件，用户体验是非常恶心和糟糕的。

如何改善这段代码？创建一个可以协作的并发系统，这个并发系统不能霸占整个循环队列，要允许别的事件进入循环队列，理想的效果类似于如果没有其他事件，那么持续执行这个虚拟进程，直到进程结束，如果有其他事件触发，那么优先执行触发事件，触发事件结束后执行其他事件。

以下给出一种简单的方案【利用异步】：
```
import React from 'react';
import axios from 'axios';

let res = [];

function complexOpe(data) { //复杂运算
    return data.map((el,i)=>el*i+99*i-el*11);
}

function responseV2(data) {
    const chunk = data.splice(0,1000);
    res = res.concat(complexOpe(chunk));
    if(data.length>0){
        setTimeout(function () {
            responseV2(data);
        },0)
    }
}

function Demo(props) {
    axios.get('').then(res=>{
        const mockData = Array(3000000).fill(1000);
        responseV2(mockData);
    });
    return <div>
        <button onClick={()=>console.log("点击成功")}>点击</button>
    </div>;
}

export default Demo;
```
执行这段代码你就会发现进程一直在批处理进行复杂运算，一旦有事件触发就会执行，事件结束后批处理继续，直到进程结束。

# 3.任务