[TOC]

# 异步编程
一句话描述异步编程：表达和控制持续一段时间的程序行为。

这里持续一段时间并不是指程序本身耗费的时间，即便是`console.log(1)`这样简单的代码也会耗费时间，这里是指存在**等待时间**的程序。

什么是等待时间？，如果一段代码一部分在现在执行，一部分在未来执行，现在与未来的这段时间间隙我称作等待时间。

如果没有这段间隙，那么就没有现在与未来之分，也就没有异步编程。

异步编程的概念正是源于等待时间的存在，等待时间区分了现在与未来，控制和表达现在和未来 正是异步编程的最佳表述。

基于此表述，我们知道存在等待时间的场景需要异步编程，比如等待用户输入、通过网络请求数据、从数据库或文件系统请求数据、固定时间执行重复任务【如动画】，等待时间可能固定或不固定，无论如何，存在等待时间，就需要使用异步编程进行控制。

异步编程简单来说就是通过一些技术手段【回调、定时器、promise等】，控制将来的代码在指定时间【等待时间之后】执行。

## 1.JS运作模式
异步编程最常见的一种状况是：程序中将来执行的部分不是在现在执行的部分结束后立即执行的.
```
let data = ajax(url);//ajax是某个ajax请求方法，url代表接口

console.log(data);//打印出来不是请求结果
```

常规的操作是这样的，利用回调进行异步编程：
```
ajax(url,(res)=>{
    consolo.log(res);//成功打印结果
})
```

对于一些新手而言，这种写法可能不如前一种写法好理解，他们或许希望获取响应数据后再继续下面的代码。

这种想法从技术上可以实现，而且实际上原生`XMLHttpRequest`是支持同步请求的，不过现在浏览器出于对用户体验的负面影响而被弃用了。

同步请求技术为什么会被弃用？这种做法会锁定页面UI，并阻塞所有交互，相当于卡死状态，所以绝对绝对不要使用同步请求。

可能有人会认为`async await`是同步请求，实际上并不是，`async await`是同步写法的异步代码【通俗来说就是形式上是同步的写法，本质上还是异步执行】。以下是一个简单的例子：

## 2.async await演示
```
    const axios = require('axios');//需要安装并引入axios库
    
    async function request() {
        const data = await api();
        console.log('data',data);
    }

    function api() {
        const url = 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/abs';
        return axios.get(url)
    }

    request();
    console.log(18);
```
执行这段代码，发现是先打印18，再打印data【此时已拿到响应数据】。

关于`async await`这里暂不详细介绍。

## 3.异步控制台
关于控制台的一些特性在调试时可能需要注意下，console.*并不属于ES规范，它们由宿主环境决定。

对于部分浏览器在一些情况下，console.log(...)不会将传入的内容立刻输入，它输出的可能是最终改变的结果。出现这种情况的主要原因是，I/O是非常低速的阻塞部分，所以浏览器会后台异步处理控制台I/O，这么做可以提高性能，相对于直接打印的结果可能会出现混淆。

```
    const obj = {
        aaaaaaaaaaaaaaaaaaaaaaa:0,
        bbbbbbbbbbbbbbbbbbbbbbb:0,
        ccccccccccccccccccccccc:0,
        eeeeeeeeeeeeeeeeeeeeeee:0,
        fffffffffffffffffffffff:0,
        name:0,
    };

    console.log(obj);

    obj.name++;
```
执行这段代码，发现打印的`obj`其`name`已经改变了。

一般推荐两种方案进行即时输出：
1. `debugger` 打断点
2. `JSON.stringify()` 把对象序列化到一个字符串中，以强制执行一次“快照”

# 事件循环机制
首先需要明确一点，JS是单线程执行，同一时间内只能做一件事。

JS的宿主环境会实现一个持续的循环，最开始，循环会将所有同步代码执行完，然后，再执行异步代码。
> 也可以认为全局同步代码是事件队列中的第一个代码块，这样JS执行本身就不存在异步这一概念了，宿主环境只是在每次循环中按顺序取出事件队列的代码块执行而已。 <br/>

异步代码如何执行，JS事件使用的是队列机制，触发一个注册的事件，就将这个事件的回调函数放到事件队列里，每一次循环，宿主环境都会区查询队列里有没有待执行的函数，如果有则依次执行。

定时器也是队列机制，设定一个定时器，定时器到时后会将回调放入队列，然后事件队列继续在每一次循环中按顺序执行。

异步就是这么回事，在我们指定的时机对应的代码块加入队列中，宿主环境会按顺序摘出里面的代码块并执行。

到这里，我们可以明白为什么定时器会执行存在时间误差了，定时器在到达时间后会立刻将回调函数加入队列不错，却不能保证此时队列没有其他代码块，代码执行是需要时间的。
> 注意：JS没有插队的机制，只能按部就班的进行排队【加入队列】

JS单线程中并没有时间/异步的概念，宿主环境只是在每次循环中按顺序取出事件队列的代码块执行而已

**JS异步编程真正控制的，是加入事件队列的时机，而非执行的时机**。

## 1.完整运行
因为JS的单线程特性，JS的函数具有**原子性**，函数一旦开始执行，直到这个函数所有代码执行完成前不会去执行其他函数，这被称为**完整运行**特性。
> 例外是es6引入的生成器，它不具有完整运行特性。

这个特性使得JS的更加可控，如果两个不同的函数其内代码可以交替运行在环境中，并且操作的是同一块内存，那么结果将难以预料。

JS的输出结果不可控一般出于函数执行顺序不同，关键原因在于异步。
> 注意：并非所有的函数执行顺序都会造成结果不可控，两者需要操作同一个值时才会对结果造成影响。

这种函数顺序的不确定性被称作**竞态条件**【race condition】。

见示例：
```
let a = 3;

function foo(){
    a = a * 3;
}

function bar(){
    a = a + 3
}

ajax(url,foo);//ajax是异步请求，请求结束后执行回调
ajax(url2,bar);

console.log(a); // 12? 18?
```
如果第一个请求先完成，则先执行`foo`,再执行`bar`,结果是12。

如果第二个请求先完成，则先执行`bar`,再执行`foo`,结果是18。

函数执行顺序不同导致结果不同，这是竞态条件的体现。

JS中会导致这种状况出现的只有异步编程，所以掌握了异步编程，从某种方面而言就等同掌握了函数执行的规则。

## 2.并发

