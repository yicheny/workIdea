[TOC]

# 异步编程
一句话描述异步编程：表达和控制持续一段时间的程序行为。

这里持续一段时间并不是指程序本身耗费的时间，即便是`console.log(1)`这样简单的代码也会耗费时间，这里是指存在**等待时间**的程序。

什么是等待时间？，如果一段代码一部分在现在执行，一部分在未来执行，现在与未来的这段时间间隙我称作等待时间。

如果没有这段间隙，那么也就没有现在与未来之分，就没有异步编程。

异步编程的概念正是源于等待时间的存在，等待时间区分了现在与未来，控制和表达现在和未来 正是异步编程的最佳表述。

基于此表述，我们知道存在等待时间的场景需要异步编程，比如等待用户输入、通过网络请求数据、从数据库或文件系统请求数据、固定时间执行重复任务【如动画】，等待时间可能固定或不固定，无论如何，存在等待时间，就需要使用异步编程进行控制。

## 1.JS运作模式
异步编程最常见的一种状况是：程序中将来执行的部分不是在现在执行的部分结束后立即执行的.
```
let data = ajax(url);//ajax是某个ajax请求方法，url代表接口

console.log(data);//打印出来不是请求结果
```

常规的操作是这样的，利用回调进行异步编程：
```
ajax(url,(res)=>{
    consolo.log(res);//成功打印结果
})
```

对于一些新手而言，这种写法可能不如前一种写法好理解，他们或许希望获取响应数据后再继续下面的代码。

这种想法从技术上可以实现，而且实际上原生`XMLHttpRequest`是支持同步请求的，不过现在浏览器出于对用户体验的负面影响而被弃用了。

同步请求技术为什么会被弃用？这种做法会锁定页面UI，并阻塞所有交互，相当于卡死状态，所以绝对绝对不要使用同步请求。

可能有人会认为`async await`是同步请求，实际上并不是，`async await`是同步写法的异步代码【通俗来说就是形式上是同步的写法，本质上还是异步执行】。以下是一个简单的例子：

## async await演示
```
    const axios = require('axios');//需要安装并引入axios库
    
    async function request() {
        const data = await api();
        console.log('data',data);
    }

    function api() {
        const url = 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/abs';
        return axios.get(url)
    }

    request();
    console.log(18);
```
执行这段代码，发现是先打印18，再打印data【此时已拿到响应数据】。

关于详细`async await`这里暂不详细介绍。

