[TOC]

# 生成器是什么？
一种新的函数类型，它与一般函数类型有什么区别？不再具有原子性，或者说完整运行性。

原子性，是描述函数作为代码运行的最小单位，完整运行特性即一个函数一旦开始，到结束为止没有任何代码可以打断其运行。

# 如何使用生产器？
之前提到过回调有两大缺陷：一是缺乏信任，二是不符合人类思考流程。

Promise解决了缺乏信任的问题，另一个问题则由生成器解决了。

生成器提供了一种从中断执行函数的方式，使得我们不必依赖与回调，首先让我们回顾下过去使用回调的情况：
```
let x = 0;

function foo(cb){
    x++;
    cb();
    console.log(x);
}

function bar(){
    x++;
}

foo(bar);//2
```
注意看这段代码，有人也许认为这里不用回调，直接在里面调用`bar()`就是了，以目前来看是可以的，因为场景不是很复杂。

考虑一种场景，在`foo`函数内部，初始执行的代码时相同的，最后执行的代码也是相同的，中间的部分却是可变的。

由于函数的原子性我们想要实现中间代码可变，可以想到两种方案，一种是采用回调，即现在这种，另一种是将`foo`相同的部分拆出来成为两个新函数。

无论哪种方法都有着不小的缺陷，首先说回调，它使得`foo`接受了更多的参数，并且回调并不符合人类思考模式，分析代码会有更大的负担，另外考虑一种情况，如果`foo`函数作为一个整体，内部有多个地方可变，那就需要传递多个回调去进行控制，那就很恶心了，我们没办法在外部使用就看出这些回调在内部的顺序，迫使我们必须关注其顺序。

第二种方案相对可能好一些，它首先更符合人类的思考模式一些，而且相对于传递多个回调，分析的时候会更好分析，因为在外部我们就可以一目了然的看出回调的执行顺序。然而这种方案也有很大的问题，提取函数的原则是尽量将抽象的、可变的部分抽离出来，不变的部分保持原样，使用第二种方案将不变的部分抽离出来首先会造成创建很多的函数，增加分析成本，其次它会令这些原本存在的关系的代码变得支离破碎。

现在，我们有了生成器方案，让我们看看生成器是怎么做的：
```
let x = 0;

function *foo(){
    x++;
    yield;//暂停，下次执行从这里继续
    console.log(x);
}
function bar(){
    x++;
}

let it = foo();//构造一个迭代器来控制生成器执行
it.next();//启动生成器
bar();
it.next();//2
```
看见了吗？利用生成器我们现在我们可以中断函数的执行然后再继续了，如此一来，我们可以更好的操作代码的执行了，相比于过去的函数，生成器很好的解除了代码的耦合性。

生成器也不是毫无负担的，在示例中我们看到，控制生成器还需要构造一个迭代器，不过相比于生成器带来的好处，这是完全可以接受的，就和Promise一样。Promise也不是毫无负担，它使用了一系列的机制确保回调可信任，代价是相比于裸回调速度会稍慢一些，不过这是绝对值得的。

## 输入输出
同样可以接收参数输入，不过输出时略有不同，请看：
```
function *foo(x,y) {
    return x*y;
}

const it = foo(3,9);
const res = it.next();//启动生成器
console.log(res.value);//27
```
此例中`it.next()`返回的是一个对象，这个对象有两个属性`value`、`done`，其中`done`是一个布尔值，代码生成器是否已经执行结束，`value`则是`yeild`或`return`的返回值。

直到现在为止，生成器有一个重要的能力没有提到，我们知道生成器的`yield`将函数中断了以便执行其他函数，有时候中断执行的其他函数相互之间是有所关联的，我们可以认为这些函数是主函数的可变点，那么如何在这些函数中传递信息，这一点至关重要，否则这些函数无法合作，就没办法真正的做到解耦。

下面我们看一下生成器是怎么传递信息的。

## 迭代消息传递
```
function *foo(x) {
    let y = x * (yield 'haha');//注意，这里yield会承载下一次传递进来的参数
    return y;
}
const it = foo(8);
let res = it.next();//注意，启动生成器时不要传递任何参数，因为内部没有yield进行接收
console.log(res.value);//'haha'
res = it.next(7);//注意，此时next将参数传递给了第一个yield
console.log(res.value);//56
```
观察此例，可以看见我们通过`yield`返回值向外传递值；通过`next`接收参数，在内通过`yield`传递值。

现在，我们利用`yield`和`next`就可以进行消息的双向传递了，此两者构成了生成器的双向消息传递系统。

值得注意的是，第一个`next()`用于启动生成器，`yield`向外传递参数，绝对不要在启动生成器时传递参数，因为第一个`yield`接收的是第二个`next`的参数。

关于这里，你可以这么想，每一个`yield`都会提出一个问题：我应该接收什么值？，能够回应这个问题的必定不会是当前的`next`，那么只有下一个`next`可以回应当前`yield`的问题，所以`next`是将消息传递给上一个提问的`yield`。

`yield`的另一个作用就是回应`next`的提问，它的返回值就是对`next`的回应，最后一次回应`next`则交由`return`去做。【如果没有显示使用return，其实只是隐式的返回了一个`return undefined`而已】。

`next`也是这么回事，它有两个作用，一个是提问一个是回应。它会提问`这一次生成器会返回什么给我呢？`，回答它这个问题的是`yield`与`return`，因而我们可以看到`next`执行总是会比`yield`关键字多一个，最后的一次提问由`return`回应

然后你看，`next`的参数是用于回答上一次`yield`进行提问，那第一次`next`自然不需要进行回答【传递参数】

总结下来就是：**先有问，再有答**
> 这里的逻辑建议理清，以免混淆

### `yield`挂起
`yield`会令所在行挂起，知道下一次启动继续执行，其中如果挂起的变量发生变化不会影响到这一行，下一次启动时该变量依旧是挂起的值，见：
```
let x = 0;

function *foo() {
    x++;
    console.log( x + (yield));//注意，yield会挂起此行，再次启动时x取的是挂起时的值1
}

const it = foo();
it.next();
x = 10;
it.next(0);//1
```

## 多个迭代器
从使用来看，我们构建一个迭代器后，似乎是通过迭代器在控制生成器本身，实际上不是，可以认为迭代器控制的是生成器生成的一个实例，多个迭代器之间是没有关联的，甚至可以交互使用。
```
function *foo() {
    let x = yield 2;
    z++;
    let y = yield (x*z);
    console.log(x,y,z);
}

let z = 1;
let it1 = foo();
let it2 = foo();

let v1 = it1.next().value;//2
let v2 = it2.next().value;//2

v1 = it1.next(v2 * 10).value;//40 -> x:20 z:2 
v2 = it2.next(v1 * 5).value;//600 -> x:200 z:3

it1.next(v2/2);//20,300,3 -> y:300 
it2.next(v1/4);//200,10,3 -> y:10
```

## 交替运行
现在有两个普通函数：
```
let a = 1;
let b = 2;

function foo(){
    a++;
    b = b*a;
    a = b+3;
}
function bar(){
    b--;
    a = 8+b;
    b = a*2;
}
```
基于函数的原子性，假定这两个函数执行一次，我们很好的推导出a和b的值，因为只有两种可能，要么foo先执行，要么bar先执行，一旦确认所有代码的顺序都可以确定了，因为函数具有完整运行的特性。

完整运行的特性使得我们分析代码变得简单，也使得代码耦合度较高，如果是生成器，在刚刚的两种函数内可以设置`yield`，那么有多少种可能？至少有几十种可能，这带给我们更大的自由，然而使用不慎也会为我们的代码分析带来一定的难度。

先让我实现一个`step`函数，用于接下来的测试：
```
function *foo() {
    yield 1;
    yield 2;
    yield 4;
}

function step(gen) {
    let it = gen();
    let last;
    return function () {
        console.log(last);
        last = it.next(last).value;
    }
}

let it = step(foo);
it();//undefined
it();//1
it();//2
it();//4
```
这个step函数的作用很简单，就是将每次`yield`的返回值，作为下一次`next`的参数

现在我们将这两个函数改成生成器：
```
let a = 1;
let b = 2;

function step(gen) {
    let it = gen();
    let last;
    return function () {
        last = it.next(last).value;
    }
}
function *foo(){
    a++;
    yield;
    b = b*a;
    a = (yield b)+3;
}
function *bar(){
    b--;
    yield;
    a = (yield 8)+b;
    b = a*(yield 2);
}

//测试部分
let s1 = step(foo);
let s2 = step(bar);

s2();//b-- b:1
s2();//yield 8
s1();//a++ a:2
s2();//8+b a:9
     //yield 2
s1();//b*a b:9
     //yield b
s1();//b+3 a:12
s2();//9*2 b:18 
console.log(a,b);//12 18
```
可以看见，这种写法有多恶心，实际开发基本不会出现这种故意恶心人的写法，这里是为了演示两个生成器实例交替运行代码。

如果感兴趣，可以将执行顺序多替换几次，分析执行流程。

## 迭代器
在某些场景下，我们可能需要生成一系列相关的值：
```
let valueFor = (function () {
    let value = 1;
    let init = true;

    return function () {
        if(init){
            init=false;
            return value;
        }
        return value=value*3+10;
    }
})();

console.log(valueFor());//1
console.log(valueFor());//13
console.log(valueFor());//49
```
我们使用闭包实现了这个需求。

### 实现外迭代器模式
利用生成器模式创建的迭代器，设计模式中的外迭代器模式很相似，一般迭代器用于一系列相关的数值中，现在我们简单实现一个外迭代模式：
> 注：严格来说，这不是一个规范的外迭代模式，不过这种实现方式更易于我们分清生成器、iterable、迭代器之间的关系<br/>
> 如果需要一个更规范的迭代器模式，那么将生产值的部分去掉，再增加一些对于迭代的处理即可，可以尝试自己实现一下，我将这部分实现放在文档的最后部分。
```
//定义迭代器函数【定义成类也可以】
 function genIterator(initValue=0){
    let value = initValue;
    let init = true;

    return {
        [Symbol.iterator]:function(){return this},//for-of需要
        next:()=>({
            value:valueFor(),
            done:false
        })
    };

    function valueFor() {
        if(init){
            init=false;
            return value;
        }
        return value=value*3+10;
    }
}

//测试
const it = genIterator(1);
console.log(it.next().value);//1
console.log(it.next().value);//13
console.log(it.next().value);//49

for(let v of genIterator(1)){//注意这里，这里表明genIterator不是`iterable`，`genIterator(1)`会创建一个`iterable`，并且每次迭代的迭代器也是一个`itreable`
    console.log(v);//1 13 49 157 481
    if(v>200) break;
}
```
定义迭代器里，有一些细节说一下：
- `[]`：这种语法被称作`计算属性名`，内部可以执行表达式，表达式的最终结果即为属性名
- `Symbol.iterator`：首先Symbol是ES6新增的基本数据类型，而`Symbol.iterator`是ES6预定义的特殊Symbol值

有一些与迭代器模式紧密相关的名词介绍一下，一般来说，`iterable`【可迭代】是指有能力返回迭代器的对象。就刚刚的那个例子来说，`it`是`iterable`，而`genIterator`则类似于生成器

在ES6中`iterable`定义更严谨一些，`iterable`必须支持一个函数，其名称是专门的ES6符号值`Symbol.iterator`，调用此方法时会返回一个迭代器

从我们实现中可以看出`iterabel`也可以是迭代器，两者并不冲突。

### 生成器、iterable、迭代器
现在，回到生成器，生成器并不是`iterable`，这一点一定要明确，生成器如其名，负责生产值，回想刚刚我们所作的那个实现你就会发现一点，生成器和`genIterator`一样，两者只负责生产值，而真正的`iterable`会在是另一个，或许我们可以认为生成器可以创建`iterable`，`iterable`才是用于产生迭代器的，而`iterable`每次调用`next`会执行一次生成器，得到一个值，并通过`next`返回，就是这样。
> 注意理清 生成器、iterable、迭代器之间的关系

让我们用生成器进行实现刚刚的例子：
```
function *foo(initValue=0){
    let value = initValue;
    let init = true;

    while(true){
        if(init){
            init=false;
            yield value;
        }

        yield value = value*3+10;
    }
}

//测试
const it = foo(1);//注意，it才是itreable
console.log(it.next().value);//每次next都会执行一次生产器，接收值并返回
console.log(it.next().value);
console.log(it.next().value);
console.log(it.next().value);

for(let v of foo(1)){ //注意这里，这里表明生成器foo不是`iterable`，`foo(1)`会创建一个`iterable`，并且每次迭代的迭代器也是一个`itreable
    console.log(v);//1 13 49 157 481
    if(v>200) break;
}
```
和我们实现的`genIterator`相比,生成器没有显示的创建`iterable`，使得我们可以更专注于生产值上，不过本质上原理是一致的，知道即可。


#### 停止生成器
在思考一个问题，在刚刚的`for-of`，break退出循环之后，生成器foo会被如何处理，一直被挂起吗？

这涉及到一个隐藏的特性，`for-of`循环的如果提前结束（break、return、未捕获异常等），会向生成器的迭代器发送一个信号使其终止，如果正常结束，`for-of`也会传递终止信号。

如果有些代码需要结束后也必须执行，那么可以在生成器内部使用`try-finally`
```
function *foo(initValue=0){
    try {
        let value = initValue;
        let init = true;

        while(true){
            if(init){
                init=false;
                yield value;
            }

            yield value = value*3+10;
        }
    }finally {
        console.log('clean up!')
    }
}

//测试部分
for(let v of foo(1)){
    console.log(v);
    if(v>200) break;
}
```
另外，通过`iterable`的API`return`可以手动终止生成器执行，测试代码见下：
```
const it = foo(1);
console.log(it.next().value);//1
console.log(it.next().value);//13
console.log(it.return('终止任务').value);//先：'clean up!' 后：'终止任务'
console.log(it.next().value);//undefined
console.log(it.next().value);//undefined
```
生成器的确如同其名可以用于生产值，不过这却不是它的主要应用场景，异步并发才是它真正大显身手的时刻，下面让我们来见识一下。

## 异步迭代生成器
在异步和回调场景使用生成器是其最重要的使用方式，掌握如何在这两种场景下使用生成，可以自豪的说自己真正会使用了生成器了，知道生成器的基本使用并不能