[TOC]

# 生成器是什么？
一种新的函数类型，它与一般函数类型有什么区别？不再具有原子性，或者说完整运行性。

原子性，是描述函数作为代码运行的最小单位，完整运行特性即一个函数一旦开始，到结束为止没有任何代码可以打断其运行。

# 生成器的作用？
之前提到过回调有两大缺陷：一是缺乏信任，二是不符合人类思考流程。

Promise解决了缺乏信任的问题，另一个问题则由生成器解决了。

生成器提供了一种从中断执行函数的方式，使得我们不必依赖与回调，首先让我们回顾下过去使用回调的情况：
```
let x = 0;

function foo(cb){
    x++;
    cb();
    console.log(x);
}

function bar(){
    x++;
}

foo(bar);//2
```
注意看这段代码，有人也许认为这里不用回调，直接在里面调用`bar()`就是了，以目前来看是可以的，因为场景不是很复杂。

考虑一种场景，在`foo`函数内部，初始执行的代码时相同的，最后执行的代码也是相同的，中间的部分却是可变的。

由于函数的原子性我们想要实现中间代码可变，可以想到两种方案，一种是采用回调，即现在这种，另一种是将`foo`相同的部分拆出来成为两个新函数。

无论哪种方法都有着不小的缺陷，首先说回调，它使得`foo`接受了更多的参数，并且回调并不符合人类思考模式，分析代码会有更大的负担，另外考虑一种情况，如果`foo`函数作为一个整体，内部有多个地方可变，那就需要传递多个回调去进行控制，那就很恶心了，我们没办法在外部使用就看出这些回调在内部的顺序，迫使我们必须关注其顺序。

第二种方案相对可能好一些，它首先更符合人类的思考模式一些，而且相对于传递多个回调，分析的时候会更好分析，因为在外部我们就可以一目了然的看出回调的执行顺序。然而这种方案也有很大的问题，提取函数的原则是尽量将抽象的、可变的部分抽离出来，不变的部分保持原样，使用第二种方案将不变的部分抽离出来首先会造成创建很多的函数，增加分析成本，其次它会令这些原本存在的关系的代码变得支离破碎。

现在，我们有了生成器方案，让我们看看生成器是怎么做的：
```
let x = 0;

function *foo(){
    x++;
    yield;//暂停，下次执行从这里继续
    console.log(x);
}
function bar(){
    x++;
}

let it = foo();//构造一个迭代器来控制生成器执行
it.next();//启动生成器
bar();
it.next();//2
```
看见了吗？利用生成器我们现在我们可以中断函数的执行然后再继续了，如此一来，我们可以更好的操作代码的执行了，相比于过去的函数，生成器很好的解除了代码的耦合性。

生成器也不是毫无负担的，在示例中我们看到，控制生成器还需要构造一个迭代器，不过相比于生成器带来的好处，这是完全可以接受的，就和Promise一样。Promise也不是毫无负担，它使用了一系列的机制确保回调可信任，代价是相比于裸回调速度会稍慢一些，不过这是绝对值得的。

## 输入输出
同样可以接收参数输入，不过输出时略有不同，请看：
```
function *foo(x,y) {
    return x*y;
}

const it = foo(3,9);
const res = it.next();//启动生成器
console.log(res.value);//27
```
此例中`it.next()`返回的是一个对象，这个对象有两个属性`value`、`done`，其中`done`是一个布尔值，代码生成器是否已经执行结束，`value`则是`yeild`或`return`的返回值。

直到现在为止，生成器有一个重要的能力没有提到，我们知道生成器的`yield`将函数中断了以便执行其他函数，有时候中断执行的其他函数相互之间是有所关联的，我们可以认为这些函数是主函数的可变点，那么如何在这些函数中传递信息，这一点至关重要，否则这些函数无法合作，就没办法真正的做到解耦。

下面我们看一下生成器是怎么传递信息的。

## 迭代消息传递
```
function *foo(x) {
    let y = x * (yield 'haha');//注意，这里yield会承载下一次传递进来的参数
    return y;
}
const it = foo(8);
let res = it.next();//注意，启动生成器时不要传递任何参数，因为内部没有yield进行接收
console.log(res.value);//'haha'
res = it.next(7);//注意，此时next将参数传递给了第一个yield
console.log(res.value);//56
```
观察此例，可以看见我们通过`yield`返回值向外传递值；通过`next`接收参数，在内通过`yield`传递值。

现在，我们利用`yield`和`next`就可以进行消息的双向传递了，此两者构成了生成器的双向消息传递系统。

值得注意的是，第一个`next()`用于启动生成器，`yield`向外传递参数，绝对不要在启动生成器时传递参数，因为第一个`yield`接收的是第二个`next`的参数。

关于这里，你可以这么想，每一个`yield`都会提出一个问题：我应该接收什么值？，能够回应这个问题的必定不会是当前的`next`，那么只有下一个`next`可以回应当前`yield`的问题，所以`next`是将消息传递给上一个提问的`yield`。

`yield`的另一个作用就是回应`next`的提问，它的返回值就是对`next`的回应，最后一次回应`next`则交由`return`去做。【如果没有显示使用return，其实只是隐式的返回了一个`return undefined`而已】。

`next`也是这么回事，它有两个作用，一个是提问一个是回应。它会提问`这一次生成器会返回什么给我呢？`，回答它这个问题的是`yield`与`return`，因而我们可以看到`next`执行总是会比`yield`关键字多一个，最后的一次提问由`return`回应

然后你看，`next`的参数是用于回答上一次`yield`进行提问，那第一次`next`自然不需要进行回答【传递参数】

总结下来就是：**先有问，再有答**
> 这里的逻辑建议理清，以免混淆

### `yield`挂起
`yield`会令所在行挂起，知道下一次启动继续执行，其中如果挂起的变量发生变化不会影响到这一行，下一次启动时该变量依旧是挂起的值，见：
```
let x = 0;

function *foo() {
    x++;
    const y = x + (yield);//注意，yield会挂起此行，再次启动时x取的是挂起时的值1
    console.log(y);
}

const it = foo();
it.next();
x = 10;
it.next(0);//1
```

## 多个迭代器
从使用来看，我们构建一个迭代器后，似乎是通过迭代器在控制生成器本身，实际上不是，可以认为迭代器控制的是生成器生成的一个实例，多个迭代器之间是没有关联的，甚至可以交互使用。
```
function *foo() {
    let x = yield 2;
    z++;
    let y = yield (x*z);
    console.log(x,y,z);
}

let z = 1;
let it1 = foo();
let it2 = foo();

let v1 = it1.next().value;//2
let v2 = it2.next().value;//2

v1 = it1.next(v2 * 10).value;//40 -> x:20 z:2 
v2 = it2.next(v1 * 5).value;//600 -> x:200 z:3

it1.next(v2/2);//20,300,3 -> y:300 
it2.next(v1/4);//200,10,3 -> y:10
```

## 交替运行
现在有两个普通函数：
```
let a = 1;
let b = 2;

function foo(){
    a++;
    b = b*a;
    a = b+3;
}
function bar(){
    b--;
    a = 8+b;
    b = a*2;
}
```
基于函数的原子性，假定这两个函数执行一次，我们很好的推导出a和b的值，因为只有两种可能，要么foo先执行，要么bar先执行，一旦确认所有代码的顺序都可以确定了，因为函数具有完整运行的特性。

完整运行的特性使得我们分析代码变得简单，也使得代码耦合度较高，如果是生成器，在刚刚的两种函数内可以设置`yield`，那么有多少种可能？至少有几十种可能，这带给我们更大的自由，然而使用不慎也会为我们的代码分析带来一定的难度。

先让我实现一个`step`函数，用于接下来的测试：
```
function *foo() {
    yield 1;
    yield 2;
    yield 4;
}

function step(gen) {
    let it = gen();
    let last;
    return function () {
        console.log(last);
        last = it.next(last).value;
    }
}

let it = step(foo);
it();//undefined
it();//1
it();//2
it();//4
```
这个step函数的作用很简单，就是将每次`yield`的返回值，作为下一次`next`的参数

现在我们将这两个函数改成生成器：
```
let a = 1;
let b = 2;

function step(gen) {
    let it = gen();
    let last;
    return function () {
        last = it.next(last).value;
    }
}
function *foo(){
    a++;
    yield;
    b = b*a;
    a = (yield b)+3;
}
function *bar(){
    b--;
    yield;
    a = (yield 8)+b;
    b = a*(yield 2);
}

//测试部分
let s1 = step(foo);
let s2 = step(bar);

s2();//b-- b:1
s2();//yield 8
s1();//a++ a:2
s2();//8+b a:9
     //yield 2
s1();//b*a b:9
     //yield b
s1();//b+3 a:12
s2();//9*2 b:18 
console.log(a,b);//12 18
```
可以看见，这种写法有多恶心，实际开发基本不会出现这种故意恶心人的写法，这里是为了演示两个生成器实例交替运行代码。

如果感兴趣，可以将执行顺序多替换几次，分析执行流程。

