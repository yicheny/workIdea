[TOC]

# 基础回顾
观察者模式，又叫做发布订阅模式，它定义对象之间一对多的依赖关系：当一个对象的状态发生改变时，所有依赖于它的对象都会 察觉到变化/收到通知

## 练习实例：买手机的故事
小红、小明、小强三人都想买苹果最近新出的手机iphone 11Pro,但是由于目前手机价格高昂【12699】,三人准备观望一段时间等手机降价再购买。

小红的预期价格是11999，小明的预期价格是5699，小强的预期价格是8899。

为了得到手机的最新价格，三人每隔一个小时向客服打一次电话。

用代码实现这个例子：
```
//购买者抽象类
class Buyer {
    buyPhone = (price)=>console.error('子类必须重写buyPhone方法');
}

//购买者子类小红
class Hong extends Buyer{
    buyPhone = (price)=>{
        if(price > 11999) return console.log(`iphone11 Pro价格为${price}元，小红觉得价格太高，暂时观望`);
        return console.log(`iphone11 Pro价格为${price}元，小红购买了iphone11 Pro!`)
    }
}

//购买者子类小明
class Ming extends Buyer{
    buyPhone = (price)=>{
        if(price > 5699)return console.log(`iphone11 Pro价格为${price}元，小明觉得价格太高，暂时观望`);
        return console.log(`iphone11 Pro价格为${price}元，小明购买了iphone11 Pro!`)
    }
}

//购买者子类小强
class Qiang extends Buyer{
    buyPhone = (price)=>{
            if(price > 8899) return console.log(`iphone11 Pro价格为${price}元，小强觉得价格太高，暂时观望`);
            return console.log(`iphone11 Pro价格为${price}元，小强购买了iphone11 Pro!`)
        }
}

const hong = new Hong();
const ming = new Ming();
const qiang = new Qiang();

let price = 12699;
hong.buyPhone(price);
ming.buyPhone(price);
qiang.buyPhone(price);

hong.buyPhone(price);//价格没有变化，但是小红还是进行了查询
price = 10888;
ming.buyPhone(price);
hong.buyPhone(price);//小红成功购买了手机，不再查询

price = 11122;
qiang.buyPhone(price);
ming.buyPhone(price);//小明与小强查询次数的不一致体现了两人的关注度不同
ming.buyPhone(price);
ming.buyPhone(price);

//价格变化与查询中...

price = 4888;
qiang.buyPhone(price);//小强成功购买了手机，不再查询
ming.buyPhone(price);//小明成功购买了手机，不再查询

```
在这段演示代码中，小明、小红、小强会不断的对价格进行查询，直到购买到手机为止。

这种不间断查询的行为是很耗费精力并且大多数时候都是没有意义的。

可以改进的地方在这里：在价格变化时主动通知消费者 是更好的实现。

为此我们创建一个观察者类并使用：
```
//观察者
class Observer{
    constructor(){
        this.customs = [];//消费者列表
    }
    
    add(name,event){ //添加消费者
        this.customs.push({name,event});
    }
    
    remove(name){ //从列表移除指定消费者
        if(!name)return this.customs = [];//如果不传指定名称则清空列表
        this.customs = this.customs.filter(item=>item.name!==name);
    }
    
    inform(...rest){ //通知列表上的消费者【也可以设置成通知指定的消费者】
        this.customs.forEach((item)=>item.event(...rest))
    }
}

const observer = new Observer();

const hong = new Hong();
const ming = new Ming();
const qiang = new Qiang();
observer.add('hong',hong.buyPhone);
observer.add('ming',ming.buyPhone);
observer.add('qiang',qiang.buyPhone);

observer.inform(11888);
observer.remove('hong');//将小红从消费者列表中移除
observer.inform(10888);
observer.inform(8888);
observer.remove('qiang');//将小强从消费者列表中移除
observer.inform(6888);
observer.inform(4888);
observer.remove('ming');//将小明从消费者列表中移除
```
在这段代码中，客服【观察者】有一张消费者清单【属性】，三种能力【方法】。

三种能力能力分别是：
1. `add`:用于将消费者添加到清单列表上
2. `remove`:用于将消费者从清单列表上移除
3. `inform`:将最新变化通知清单列表上的消费者

利用好这张清单以及三种能力，消费者就不必进行无意义的重复询问行为了，只需要等待客服的通知即可。是不是感觉有一个客服【观察者】是一件很棒的事情？

其实，这个客服还可以更强大一些，关于`inform`方法，客服理论上可以更特定的通知消费者，比如说，只有在价格低于消费者的预期价时才通知对应的消费者。要完成这个要求，`add`方法添加消费者时便需要留下自己的预期价。

关于观察者类的部分需要改动下：
```
//价格观察者
class PriceObserver extends Observer{
    add(name,price,event){ 
        this.customs.push({name,price,event});
    }
    
    inform(price){ 
        this.customs.forEach((item)=>{
            if(price<=item.price) return item.event(price)
        })
    }
}

const priceObserver = new PriceObserver();

const hong = new Hong();
const ming = new Ming();
const qiang = new Qiang();
priceObserver.add('hong',11999,hong.buyPhone);
priceObserver.add('ming',5699,ming.buyPhone);
priceObserver.add('qiang',8899,qiang.buyPhone);

priceObserver.inform(11888);
priceObserver.inform(10888);
priceObserver.inform(8888);
priceObserver.inform(6888);
priceObserver.inform(4888);
```
在这里，我们新建了一个价格观察者类，它继承了Observer类并重写了`add`及`inform`方法

面对新的需求，我们应该想起 开放封闭这一原则【软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改】，添加新的功能或需求时我们应当去扩展而非修改原有的实现。

修改是有意义的，但修改应该只存在于两个地方，一个是当代码逻辑存在问题，出现bug不得不修复时；另一个是重构代码时，注意，重构是对已有实现的优化。

出现新的需求，扩展无疑是优于修改的，因为它减少了变化，bug的诞生几率更小，减少了维护的成本，当出现一个新需求时，你却发现旧有的代码很难扩展，这个时候你可能会意识到这可能并不是一段好代码，在开始添加新的需求之前，如果时间并不紧急或许将这这段代码重构是更好的选择。

这是《重构·改善代码既有设计》一书作者说过的，如果你觉得一段代码难以理解或修改，那么在添加新的特性之前，有必要将其整理的清晰一些，让它更容易理解与修改，不需要做到完美，只需要比你看到的更干净一些就可以，这就是**营地原则**，如果我们每次修改都能保证这一次的代码比之前的更好，那么它终有一天会变得很好。一直放着糟糕的代码不管，那么它会变得更加糟糕，因为垃圾只会产生更多更大的垃圾。
