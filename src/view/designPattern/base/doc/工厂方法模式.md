[TOC]

# 目的
定义一个创建对象（实例化对象）的接口，让子类来决定创建哪个类的实例。
> 工厂方法使一个类的实例化延迟到其子类

# 练习：小明的新工厂
继续[工厂方法模式](http://localhost:3020/#/design/base/simpleFactory)里小明的工厂发展之路，现在小明工厂做大了，想要在生产玩具之外，生产一些袜子，比如连裤袜【pantynose】，长筒袜【stocking】。

生产袜子和生产玩具不同，允许定制的是价格及质量【quality】

直接使用工厂方法模式实现

## 小明的新工厂V1
### 玩具类部分
```
class Toy {
    constructor(props){
        const {name=null,size=20,color='white'} = props;
        this.name=name;
        this.size=size;
        this.color=color;
    }
}

class ToyYoyo extends Toy{
    constructor(props){
        super(props);
        this.name = '悠悠球';
        console.log('悠悠球生产成功',this);
    }
}

class ToyBabi extends Toy{
    constructor(props){
        super(props);
        this.name = '芭比娃娃';
        console.log('芭比娃娃生产成功',this);
    }
}
```
### 袜类部分
```
class Sock {
    constructor(props){
        const {name=null,quality='normal',price=0} = props;
        this.name=name;
        this.quality=quality;
        this.price=price;
    }
}

class SockPantynose extends Sock{
    constructor(props){
        super(props);
        this.name = '连裤袜';
        console.log('连裤袜生产成功',this);
    }
}

class SockSocking extends Sock{
    constructor(props){
        super(props);
        this.name = '长筒袜';
        console.log('长筒袜生产成功',this);
    }
}
```

### 工厂类情形1_抽象工厂类实现
```
//抽象工厂类_用于定义公共的接口
class ProductFactory{
    createProduct = (type,...rest)=>console.error('子类必须重写createProduct方法');
}

//具体工厂类_生产玩具
class ToyProductFactory extends ProductFactory{
    createProduct = (type,...rest) => {
        const params = {
            size:rest[0],
            color:rest[1]
        }
        
        if(type==='yoyo') return new ToyYoyo(params);
        if(type==='babi') return new ToyBabi(params);
        return console.log(`生产失败!`)
    }
}

//具体工厂类_生产袜子
class SockProductFactory extends ProductFactory{
    createProduct = (type,...rest) => {
        const params = {
            quality:rest[0],
            price:rest[1]
        }
        
        if(type==='pantynose') return new SockPantynose(params);
        if(type==='socking') return new SockSocking(params);
        return console.log(`生产失败!`)
    }
}
```

### 测试执行
```
const toyFactory = new ToyProductFactory();
toyFactory.createProduct('yoyo',18,'red');
toyFactory.createProduct('babi',30,'blue');
toyFactory.createProduct('yoyo');
toyFactory.createProduct('dddd');

const sockProductFactory = new SockProductFactory();
sockProductFactory.createProduct('pantynose','height',1200);
sockProductFactory.createProduct('socking','normal',600);
sockProductFactory.createProduct('socking');
sockProductFactory.createProduct('dddd');
```

### 工厂类情形2_具体类实现
```

```

# 参与者
1. Product：抽象产品类_定义具体产品类的接口
2. ConcreteProduct：具体产品类【多个】_实现Product接口
3. Creator：两种情况
    - 抽象工厂类_定义具体工厂类的接口
    - 具体类_为工厂方法提供一个缺省的实现
3. ConcreteCreator：具体工厂类，用于创建具体产品类_返回一个ConcreteProduct实例
