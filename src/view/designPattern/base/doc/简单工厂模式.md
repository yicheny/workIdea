[TOC]

# 目的
定义一个创建对象（实例化对象）的接口，通过参数来决定创建哪个类的实例
> 不属于23种基础设计模式之一，但是和工厂方法模式及抽象工厂模式相关，需要掌握

# 实例:生产玩具
小明是玩具厂老板，现在玩具厂有两类玩具，一种是男生喜欢玩的悠悠球，一种是女生喜欢玩的芭比娃娃，现在需要一个程序根据不同的需求生产不同的玩具。

## 生产玩具V1
```
function createProduct(type){
    if(type==='yoyo'){
        console.log('生产悠悠球步骤1'),
        console.log('生产悠悠球步骤2'),
        console.log('生产悠悠球步骤3')
        return console.log('悠悠球生产成功');
    }else if(type==='babi'){
        console.log('生产芭比娃娃步骤1'),
        console.log('生产芭比娃娃步骤2'),
        console.log('生产芭比娃娃步骤3')
        return console.log('芭比娃娃生产成功');
    }else{
        return console.log('生产失败！');
    }
}

createProduct('yoyo');
createProduct('babi');
```
代码实现了，不过缺陷很多：
1. 生产悠悠球和生产芭比娃娃都放到`createProduct`，导致承担责任过大，将其责任分离出来更好
2. 使用`if...else`进行逻辑控制，首先看起来很不直观【不容易理解】，其次修改起来会很麻烦

## 生产玩具V2
```
function createYoyo(){
    console.log('生产悠悠球步骤1'),
    console.log('生产悠悠球步骤2'),
    console.log('生产悠悠球步骤3')
    return console.log('悠悠球生产成功');
}
function createBabi(){
    console.log('生产芭比娃娃步骤1'),
    console.log('生产芭比娃娃步骤2'),
    console.log('生产芭比娃娃步骤3')
    return console.log('芭比娃娃生产成功');
}
function createProduct(type){
    const products = {
        yoyo:createYoyo,
        babi:createBabi
    }
    
    return products[type];
}

createProduct('yoyo');
createProduct('babi');
```
到目前为止，使用的是面向过程的写法，现在我们使用面向对象的写法实现

## 生产玩具V3
```
class Product{
    createProduct=()=>console.error('子类必须重写crateProduct方法');
}

class ProductYoyo extends Product{
    create=()=>{
        console.log('生产悠悠球步骤1'),
        console.log('生产悠悠球步骤2'),
        console.log('生产悠悠球步骤3')
        return console.log('悠悠球生产成功');
    }
}

class ProductBabi extends Product{
    create=()=>{
        console.log('生产芭比娃娃步骤1'),
        console.log('生产芭比娃娃步骤2'),
        console.log('生产芭比娃娃步骤3')
        return console.log('芭比娃娃生产成功');
    }
}

class ProductFactory{
    createProduct=(type)=>{
        const products = {
            yoyo:()=>new ProductYoyo(),//这里这样做是想将实例化操作延迟一步，否则会将所有产品全部实例化影响性能
            babi:()=>new ProductBabi()
        }
        
        return products[type]();
    }
}

const productFactory = new ProductFactory();
productFactory.createProduct('yoyo').create();
productFactory.createProduct('babi').create();
```

# 参与者
1. AbstractProduct：抽象产品类
2. ConcreteProduct: 具体产品类【多个】
3. Factory：工厂类，用于创建具体产品类

# 优点
- 实现简单，结构清晰
- 解耦**类的实例化**与**实例化对象操作**的关联，分割出创建的职责【根据传入不同的参数创建对象】
- 实现了面向接口编程，符合迪米特法则【依赖倒转原则】，代码更容易维护

# 缺点
- 不易拓展，每次添加新产品都需要修改*创建部分*的代码，违背**开放封闭原则**
- 产品类型过多时，可能会导致逻辑较为复杂
> 以上是使用switch...case...或if...else...时会存在的问题，如果利用对象多态性/表格驱动法，可以在一定程度上减小复杂性

# 适用场景
- 具体产品比较少时。
- 所有产品具有相同的方法和相似的属性。
