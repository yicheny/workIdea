[TOC]

# 目的
将一个类的接口转换成客户希望的另外一个接口，adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

# 实例练习_翻译器
小明入职了一家俄国外企公司ABC，ABC公司工作指令都是通过俄文下达，小明作为土生土长的中国人，对于俄文并不了解。

实际上，工作的内容小明是会的，问题在于小明不知道指令的含义。

要解决这个问题，有以下几种方案：
1. 让小明去学俄语
2. 让公司去做一套中文指令并将过去的所有俄文指令加上中文指令
3. 找一个中间者翻译

方案1和2都需要耗费很大的时间和精力，并且方案2可能会造成混乱。

找一个中间者或许从长久角度而言并不是最好的选择，但是就目前而言是需要付出的代价中最小的。

ABC公司所选择的这个中间者是一台翻译机【适配器】，它的作用是将指令翻译成小明可以明白的中文，或者说当指令下达时它会为小明适配相应中文指令。

以代码实现这个故事

## 翻译器V1
```
//中国员工抽象类【定义公共接口】
class CStaff{
    '编程' = ()=>console.error('子类必须重定义 编程 方法');
    '测试' = ()=>console.error('子类必须重定义 测试 方法');
    '设计' = ()=>console.error('子类必须重定义 设计 方法');
}

//中国员工具体类小明
class CStaffMing extends CStaff{
    '编程' = ()=>{
        console.log('小明开始编程啦！');
    }
    
    '测试' = ()=>{
        console.log('小明开始测试啦！');
    }
    
    '设计' = ()=>{
        console.log('小明开始设计啦！');
    }
}

//外国员工抽象类
class FStaff{
    code = ()=>console.error('子类必须重定义code方法');
    test = ()=>console.error('子类必须重定义test方法');
    design = ()=>console.error('子类必须重定义design方法');
} 

//适配器类
class AdapterStaff extends FStaff{
    constructor(){
        super();
        this.adaptee = new CStaffMing();//这里也可以传入
    }

    code = ()=>this.adaptee.编程();
    test = ()=>this.adaptee.测试();
    design = ()=>this.adaptee.设计();
}

//客户端_Client【执行过程】
const staff = new AdapterStaff();
staff.code();
staff.test();
staff.design();
```
这种写法的对于维护会很友好，如果需要有其他员工需要适配，重新定义一个符合FStaff接口的适配器类，并重新new一个实例即可。

如果不使用适配器，那么就需要在使用的接口的每个方法处一一替换【比如code=>编程，test=>测试，design=>设计】，这种做法一则因为分散，修改会很困难，bug的风险高，二则即使可以一个不漏的去修改，也是一件很耗时间和精力的事情。

原则上，我们应该尽力避免去修改过程或者零散的逻辑，以免后期难以维护。

# 参与者
- Target：所需的类
- Adapter：适配器
- Adaptee：已有的类
- Client：与符合Target接口的对象协同

# 适用范围
- 希望复用一些现存的类，但是接口和复用环境要求不一致，并且难以修改接口时【一般是在项目的后期或维护期】
> 适配器模式属于亡羊补牢的做法，如果情况允许【修改不复杂的情况下】将接口统一是更好的做法，这样更简单、更直接、也更紧凑。
