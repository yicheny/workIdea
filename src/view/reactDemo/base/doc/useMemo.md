[TOC]

# 型构
## 1.名称
`useMemo`

## 2.参数
`(fn,deps)`
第一个参数是一个形如`()=>fn(a,b...)`的参数
> 注意，如果是`useCallback`返回的是这个回调函数本身，而`useMemo`返回的是这个回调函数的返回值

第二个参数是依赖项，其中任意一项改变时，就会更新`useMemo`的返回值。

## 3.返回值
第一个参数的返回值，准确的说是一个`memoized`值

# 使用场景
性能优化，准确的说是：
1. 引用相等判断
2. 昂贵的计算成本

## 1）引用相等判断
引用相等判断在`useCallback`一节已经说过了，`useMemo`只是在声明变量的时候不同，其他原理相同，这里不再赘述，重点关注第二个优化场景。
> `useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`，并且useMemo的返回值可以是任意引用类型值，所以使用场景更广泛

## 2）计算成本优化
有些函数运算可能需要很高的代价【时间或者资源】，将每次的计算结果存到缓存中，每次计算前先去查缓存，看是否是已有的相同依赖，如果是则直接取缓存值。
> 注意：useMemo仅可以当作优化手段，但不要将其缓存当作语义上的保障，因为React可能会释放/遗忘过去的一些值，所以即使是相同的输入也有可能被重新计算