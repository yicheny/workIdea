[TOC]

# 使用场景
组件需要状态时，并且这个状态相对独立【即与其他状态无关联】

## 什么时候需要状态
**需要保存变化的值**的时候。

这种值一般有两类：一类是作为数据的载体，一类是与页面的渲染【变化】相关。

作为数据的载体，比如界面上展示每个班级的学生详情，这个详情的数据是通过请求后端数据所获得的，数据改变页面自然也改变，所以数据的变化是需要监控的。

另一方面，我们如何去改变数据，一般做法是改变接口请求的参数，比如说现在请求班级的这个接口，我们传递的参数是每个班级的编号，比如`5-4`返回的是五年级四班的学生数据，`3-2`返回的是三年级二班的学生数据，这个参数也是我们需要维护的状态。

另外，这个页面上展示的详情的形式，比如说同样的数据我们可以用列表形式展示，也可以用表格类型展示，甚至可以用echarts图表展示，那么这里这个控制展示形式变化的值也需要用一个状态去维护，比如说`mode`,`mode`有`list`,`table`,`echarts`三种值，数据不变的情况改变mode的值同样会让页面重新渲染。

## 状态详解【可忽略】
状态，什么时候需要状态，很简单，那就是**需要保存变化的值**的时候。

### 生命周期状态
状态本身就意味着变化，状态是变化过程中某个确定的点，状态其实与变量很像，如果说有什么不同，变量受限于作用域，无法自由的在React的生命周期中传递【无论是全局变量还是局部变量都不是好方案】，当然变量并非无用，在局部生命周期【即这个变量只会在一个生命周期内使用】声明变量依旧是有价值和意义的。

当然，我们可以借助属性比如`this.name`,`this.age`等去存储值，这么做虽然可以在生命周期中传递，可惜变化时不会自动触发渲染【借助`forceUpdate`可以触发渲染】。

即使借助`forceUpdate`可以做到重渲染，使用属性存储值也无法替代`setState`，写法会复杂一些自不必说，更重要的是`forceUpdate`引发的强制更新与`setState`触发的生命周期并不相同。

总结下`state`、变量、属性存储的场景
- 变量：只会在一个生命周期内使用的值
- 属性：会在多个生命周期使用，但是不会改变的值【不在全局声明，是因为会造成多余的开销，浪费资源】
- 状态：在多个生命周期使用，并且会改变的值【无论这个值会不会直接渲染到页面上】
  
### Hook状态【待深入】
与生命周期相比有所变化...

# 型构【如何使用】
## 1.名称
`useState`

## 2.参数
`initialState`【初始状态】

## 3.返回值
`[state,setState]`
> 注意：useState的返回值是一个数组，数组第一项是用于维护的状态，第二项是用于修改状态的方法。<Br/>
> 返回项的命名時完全自由的，不过一般我們命名时都会遵守`[xxx,setXxx]`的形式

## 形式
`const [xxx,setXxx] = useState(initialState);`

# 详解一：setState使用
setState可接收的参数有两种，一种是新状态的值，一种是回调函数

## 1.接收新状态值作为参数
`setState(newState)` 新状态值会被赋值给state。

## 2.接收回调函数作为参数
什么时候需要使用回调函数作为参数？

**如果新的状态与现在的状态有所关联时推荐使用回调函数**。

回调函数接收的参数是现在的状态，会使用回调函数的返回值作为新状态，形如：
```
setState((currState)=>{
    const nextState = ...;//对currState的各种操作；
    return nextState;//注意，新状态是这个回调函数的返回值
})
```

# 详解二：initialState的设置
initialState也有两种设置方法，一种直接是初始状态值，一种是回调函数
## 1.初始状态值
`setState(initialState)`，此时`initialState`可以是任意类型的值【不要设置为函数或复杂对象】，这个值就是state的初始值。

## 2.回调函数作为initialState
什么时候需要使用回调函数作为`initialState`？

**如果初始state需要通过复杂计算获得**

回调函数的返回值会作为`initialState`，形如：
```
const [state,setState] = useState(()=>{
    const initialState = ...;//复杂计算，一般与props相关
    return initalState;//返回值会作为initialState
})
```

## 关于initialState的设置注意项
### 1.不要设置为函数
为什么？因为没有任何意义，函数不会作为变化的状态存在。

### 2.不要设置成复杂数据类型
更推荐使用`useReducer`管理包含多个子值的state对象，为什么？

在过去使用组件式的`setState`时，会自动合并对象，而`useState`返回的`setState`会直接将传入的对象作为新状态，而不会去合并对象。

区别请看演示：
初始状态：
```
{
    name:'ylf',
    age:101,
    money:0
}
```

组件式设置状态`setState({age:33});`

设置后得到的state为:
```
{
  name:'ylf',
  age:33,
  money:0
}
```

`useState`返回的`setState`设置状态`setState({age:33});`

设置后得到的state为`{age:33}`

区别如上所示，利用回调函数作为参数可以实现合并更新，不过不推荐这么做，做法如下

#### 2.1.实现hook下合并更新对象【不推荐】
`setState(currState=>({...currState,...updateState}))`

# 详解三：跳过state更新
这一点也是hook写法与生命周期的区别之一。

## 1.组件式state更新
如果是组件式写法，`setState`触发渲染之后，修改父组件的状态触发渲染，子组件也会进行重渲染【即便子组件没有任何状态或变量依赖父组件】。

`getDerivedStateFromProps`、`shouldComponentUpdate`、`render`、`getSnapshotBeforeUpdate`、`componentDidUpdate`等生命周期会被触发。【测试版本为16.3后的新生命周期】。[demo](http://localhost:3020/#/react/base/demo/useState_C)


## 2.函数式state更新
如果是hook写法，则会跳过子级组件的渲染即`useEffect`的执行。
> !注意：是**跳过子级组件的渲染，而非子级组件本身的执行**。

什么意思？

首先，我们知道hook写法是使用函数式写法，每次父组件的state更新，子组件函数都会被执行【useEffect内部的回调函数并不会因此执行】，比如说我们在其中做了一些计算或者操作，这些操作都会会被执行，但是组件的渲染并不会再进行一次【这里所说的渲染是指创建或修改DOM元素这一行为。】

会触发函数式组件的执行，但不会真正渲染，另一方面`useEffect`不会被触发。[demo](http://localhost:3020/#/react/base/demo/useState)