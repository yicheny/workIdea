[TOC]

# 基础
## 1.什么是函数式编程？
函数式编程是一种编程风格，比如命令式。

## 2.放弃OOP的理由
JS使用面向对象的写法存在一些问题，使用起来很笨拙：必须时刻关注`this`，代码冗余，不方便编译器分析等等。

JS拥有编写高级函数的能力，它适合函数式编程，可以很自然的使用

### 实例
现在有一个鸟群，有一个属性：鸟的数量，有两个能力/方法，一个是加入join：即两个鸟群数量叠加，另一个是繁衍mult：即两个鸟群数量相乘。

现在使用面向对象的写法实现：
```
//定义鸟群
class Bery {
    constructor(count){
        this.count = count
    }

    join = (other)=>{
        this.count = this.count + other.count;
        return this;
    };

    mult = (other)=>{
        this.count = this.count * other.count;
        return this;
    }
}

//测试代码
const b1 = new Bery(4);//b1鸟群有4只鸟
const b2 = new Bery(2);//b2鸟群有2只鸟
const b3 = new Bery(0);//b3鸟群有0只鸟

const res = b1.join(b3).mult(b2).join(b1.mult(b2)).count;//32
console.log(res);
//(b1+b3)*b2+(b1*b2)
//(4+0)*2 + (4*2) = 16;
//理论上我们是想得到16的，然而前面的赋值操作会改变的对象的值，从而导致整个计算过程出现问题
```
可以看出程序的目的，却难以分析其结果，为什么？

可变量在运算过程中永久的被改变了，以至于状态和可变值非常难以追踪，在一个小例子里已经如此，在项目里被层层传递的状态会更加的难以追踪。

ok，现在我们再使用函数式编程实现整个例子：
```
const join = (a,b)=>a+b;
const mult = (a,b)=>a*b;

const b1 = 4;
const b2 = 2;
const b3 = 0;

const res = join(mult(b2, join(b1, b3)), mult(b1, b2));
console.log(res);
```
非常简洁，达到了我们想要的效果。

有一个问题，函数嵌套让人有点难以理解，这个问题在之后会被我们解决，不过目前有更值得我们关注的东西。

仔细观察，就会发现`join`是纯粹的加法运算，`mult`是纯粹的乘法运算，这意味着什么？意味着我们可以使用一些我们熟悉的数学公式去简化代码：
```
//原代码
join(mult(b2, join(b1, b3)), mult(b1, b2));

//应用同一律 add(x,0)==x;
join(mult(b2,b1),mult(b1,b2));

//应用分配律 
mult(b1,join(b2,b2));
```
现在感觉是不是清楚多了？

你可能认为是因为这里的运算很简单所以才可以结合数学运算，实际上并不是，很多时候都可以运用数学，数学是很广泛的，如果练习一些算法或许更可以认知到这个事实。

## 3.函数式编程优点
1. 写法简洁
2. 易推理
3. 复用性极高
4. 性能优异
5. 通用易组合

# 一等公民的函数
为什么说函数式一等公民？它具备对象的一切特性，简单的说可以将它当作一个普通的对象值使用，不过它也很特殊，它是唯一可以被调用的对象。

## 1. 糟糕的范例-纯包裹函数
有的时候，我们会发现一些类似的写法，这绝非杜撰，我在项目里遇到过很多次这种写法。

现在我简单的写个错误的范例：
```
const print = s => console.log('打印字符' , s);
const foo = s=>print(s);
```
很多时候我都会看到这种形式的代码，其函数没有任何功能或职责，仅仅只是包裹了一层。

这么做不仅没有任何益处，反而造成了很多问题，一个函数将一个函数包起来，仅仅是为了延迟执行，这是一个糟糕的编程习惯。

现在我们重构一个实例：
```
//原代码--来自于npm模块包
const getServerStuff = callback => ajaxCall(json => callback(json));

//等价于
const getServerStuff = callback => ajaxCall(callback);

//等价于
const getServerStuff = ajaxCall;
```
ok,现在我们总结下包裹函数的用法存在哪些问题：
1. 增加冗余的代码量
2. 提高维护的成本
3. 提高检索/分析的成本

很容易想到的一点是，如果一个函数被不必要的包裹起来了，一旦函数发生改变，那么包裹它的函数也需要发生改变，例如：
```
//原
request = ('/mock/get/1',res=>Dispose(res));

//如果现在Dispose函数出现改动，需要处理错误，接受一个err参数，那么这里也被迫需要改动
request = ('/mock/get/1',(res,err)=>Dispose(res,err));

//而如果一开始这么使用，则不需要进行任何改动，想怎么改动参数都可以
request = ('/mock/get/1',Dispose);
```

## 2.更高的通用性--命名
一个规则，命名的时候不要局限于特定数据，尽可能使用更通用的函数名，见：
```
// 只针对当前
const validArticles = articles => articles.filter(article => article !== null && article !== undefined),

// 对未来更友好
const compact = xs => xs.filter(x => x !== null && x !== undefined);
```

## 3.!!小心`this`
实际上，在函数式编程中绝不要使用`this`，`this`糟糕透顶，令人难以忍受，如果是面向对象的写法难免会使用，但在函数式编程中，`this`是毫无必要的，我奉劝你丢弃它，立刻。

JS中的`this`调用时动态绑定的，如果某底层方法使用了`this`，那么调用的时候一定要注意：
```
var fs = require('fs');

// 糟糕透顶
fs.readFile('freaky_friday.txt', Db.save);

// 安全一些
fs.readFile('freaky_friday.txt', Db.save.bind(Db));
```

# 纯函数
**纯函数**即相同的输入永远会得到相同的输出，没有任何可观察的副作用。

例如数组方法`slice`便符合纯函数的定义，而`splice`则会改变原函数【副作用】。

## 1.追求可靠的函数
函数式编程讨厌会改变原数据的函数，我们追求的是可靠的函数。

```
//不纯的写法
let min = 10;

function checkAge(age){
    return age>=min;
}

//纯函数写法
function checkAge(age){
    const min = 10;
    return age>=min;
}
```
第一个函数为什么不纯？因为结果依赖于`min`，而`min`是可变量，这意味着结果依赖于系统状态，引入外部环境，会增加认知负荷。

以目前来看影响不是很明显，然而这种依赖外部状态的函数会成为影响系统复杂度的一个重要因素。

输入值之外的因素可以影响返回值，会让我们的思考程序的时候痛苦不堪。

纯函数里，我们应该保证除了参数之外，一切都是固定不变的，纯函数要做到自给自足。

在这里也可以使用`Object.freeze`将对象冻结：
```
const immutableState = Object.freeze({
    min:10
})
```

## 2. 副作用
**副作用**是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互

副作用包含但不限于：
1. 更改文件系统
2. 往数据库插入记录
3. 发送一个 http 请求
4. 可变数据
5. 打印/log
6. 获取用户输入
7. DOM 查询
8. 访问系统状态...

概括而言，只要与函数外部环境发生交互就是副作用——这点是函数式编程的一个重要问题，要做到无副作用编程是需要一定技巧和实践的。函数式编程的哲学认为副作用是导致不正当行为的主要原因。

禁止一切副作用并不那么现实，我们需要做到，是将它们放在可控制的范围内。

副作用让一个函数变得不纯的原因：从定义上来说，纯函数必须要能够根据相同的输入返回相同的输出；如果函数需要跟外部事物交互，那么就无法保证这一点。

## 3.追求纯函数的理由
注意数学上函数的定义：函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值

### 1)可缓存性
纯函数总能够根据输入来做缓存。实现缓存的一种典型方式是 memoize 技术：
```

```