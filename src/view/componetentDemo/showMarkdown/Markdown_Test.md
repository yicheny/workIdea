[TOC]

# 数据类型
计算机需要处理不同的数据类型，众所周知，计算机现在可以进行很多任务：算术运算、文字编辑、图片处理、视频播放、录制音频等等不一而足

在计算机科学中，使用**多媒体**一词描述包含数字、文字、图像、音频、视频等信息

在计算机内部，所有的外部信息都会被转换成位模式存储。

## 位
**位（bit，binary digit）是计算机存储的最小单位**，它是0或1。

**位模式，也叫位流，是由多个位组成的序列**，例如`10101111`就是8个位组成的位模式，通常长度为8的位模式被称作1个字节。

一些在之后会提到的点：
- 数据压缩
- 错误检查和纠正

# 存储数字
数字在存储到计算机前会被转换为二进制，但是现在有两个问题需要解决：
- 如何存储数字的正负号？
- 如何显示十进制的小数点？

目前有两种存储方案：定点和浮点

## 定点表示法_存储整数
定点表示法用于存储整数，定点表示法没有小数部分。

### 1.无符号表示法
只用于存储没有符号的整数，理想是0到无穷大之间，不过计算机会分配n位用于定义最大无符号整数常量，这个最大常量即为`(2^n)-1`

存储无符号整数步骤如下：
- 转换为二进制
- 如果转换后的二进制数不满n位，则在左边补0，使得总位数为n (如果溢出则只保存最右边的n位数字)

示例：
```
将7存储在 8位存储单元中：
1. 转换为二进制111
2. 补足位数，得到00000111
3. 存储00000111
```

#### 溢出
```
将十进制数20存储到 4位存储单元中：
1. 转换为二进制 10100
2. 溢出：只保存最右边的4位，得到0100
3. 存储0100
```

#### 无符号表示法的应用
无符号表示可以调高存储的效率，因为不必存储整数符号，所有的位都可以用于存储数字。

常用场景如下：
- **计数**：从0或1开始增长
- **寻址**：一些计算机语言中，存储单元会存储另一个存储单元的地址，这个地址也是使用无符号表示法存储的
- **其他数据存储**：其他数据类型比如文本、图像、音频、视频等，都是通过无符号表示法存储的

### 2.符号加绝对值表示法
与无符号表示法的区别在于会有一位用于存储符号，相同位数的情况下，符号加绝对值表示法所能表达的最大值只有无符号表示法最大值的一半`2^(n-1) -1`。

另外需要注意的是，这种表示法下，正0和负0实际保存并不相同。

存储整数步骤如下：
- 转换为二进制
- 如果转换后的二进制数不满n-1位，则在左边补0，使得总位数为n-1位
- 加符号位：在最左边补0或1【0为正，1为负】
- 溢出处理
```
将十进制数-28存储在 8位存储单元：
1. 转换位二进制数： 11100
2. 补零：0011100
3. 加符号位：10011100
4. 存储10011100 
```

#### 溢出
符号加绝对值表示法有正负两种溢出的情况，需要分别对待：这里暂时不太理解，待后续补充...

```

```

#### 符号加绝对值表示法的应用
- 通常用于采样模拟信号，比如音频
- 不用于存储整数，而是用于存储实数，后续会提到

### 3.二进制补码表示法
几乎所有计算机在存储有符号整数时使用的都是二进制补码表示法。

这个方法将整数分为两个相等的子范围，首位【最左位】为0表示正数，首位为1表示负数，见示例：
```
000 001 010 011 100 101 110 111
 0   1   2   3  -4  -3  -2  -1
 
或者也可以这么看：
100 101 110 111 000 001 010 011 
-4  -3  -2  -1   0   1   2   3
```

下面介绍两种运算方法：反码、补码

#### 反码
很简单，将位模式里的所有位中的1变为0，0变为1，示例：
```
原位模式： 00110110
反码运算： 11001001
```
#### 补码
两步：
1. 从右向左复制位，直到第一次复制1
2. 其余【左侧】没有被复制的位进行反转

补码示例：
```
原位模式： 00110100
补码运算： 11001100
```

了解了这两种运算之后，现在说一下二进制补码表示法式如何存储整数的：

#### 二进制补码存储整数
三步：
1. 转换为2进制
2. 补位
3. 如果整数是正数或0，则原样存储；如果是负数则取其补码存储

存储示例：
```
将十进制数28存储到 8位存储单元
1.转换为二进制： 11100
2.补位： 00011100
3.正数原样存储： 存储00011100

将十进制数-28存储到 8位存储单元
1.转换为二进制： 11100
2.补位： 00011100
3.负数补码存储： 存储11100100
```

#### 二进制补码还原整数【十进制】
两步：
1. 首位为1，取补码；首位为0，不操作
2. 将得到的二进制整数转换为十进制
3. 加上符号

还原示例：
```
将存储在8位存储单元的00001101还原成十进制整数
1. 首位为0，不操作： 00001101
2. 二进制转换： 13
3. 加上符号【可选】：+ 13

将存储在8位存储单元的11100110还原成十进制整数
1. 首位为1，取补码：00011010
2. 十进制转换： 26
3. 加上符号： -26
```

#### 二进制补码表示法的溢出
和符号加绝对值表示法的溢出处理相同。

#### 二进制补码表示法的应用
如今，二进制补码表示法是计算机存储整数的标准表示法，它会为运算带来很大简便，之后会介绍这一点

## 浮点表示法_存储实数
**实数是带有整数部分和小数部分的数字**,计算机中不使用定点表示法存储实数，因为有精度受损的情况。

为了维持正确度或精度，计算机中存储实数使用的是浮点表示法

### 浮点表示法的构成
三部分：
- 符号： 0或1
- 指数：定义小数点移动的位数，使用余码表示法存储【因为位移可以为负】
- 尾数：定义了数字的精度【**注意，尾数是用无符号表示法存储的，但是补零在右侧**】
> 指数 = 位移量 + 余码

关于浮点数表示法，必须先提到科学计数法：
```
十进制数： + 7 425 000 000 000 000 000.00
科学计数法：+ 7.425 * (10^21)

十进制数： - 0.000 000 000 000 023 2
科学计数法： - 2.32 * (10^-14) 
```
科学计数法的好处就是写起来更短更省空间，很明显。

注意，为了使表示法的固定部分统一，科学计数法和浮点表示法都在小数点左边使用了唯一的非0标识，这被称作规范化，示例：
```
十进制  d.xxxxxxxxxxx 注意：d是1到9，x是0到9
二进制  1.yyyyyyyyyyy 注意：y是0或1
```

二进制数规范化后，我们只需要保存3部分信息：符号、指数、尾数，示例
```
原二进制数： + 1000111.0101
转换位科学计数法： + 2^6 * 1.0001110101
保存信息： +【符号】 6【指数】 0001110101【尾数】

注意：尾数保存时1.并没有被存储，它们是隐含的
```

#### 余码表示法/偏移表示法
> 浮点表示法中的指数存储使用的就是余码表示法

所谓余码表示法，就是保留无符号整数，然后选择一个整数作为偏移量。大于偏移量的即为正，小于偏移量的即为负。选择偏移量为x，则被称作余x码。

一般我们选择的偏移量是2^(n-1) -1 【可以想象是将所有数劈成两半，然后选取偏向左边的中间数】

##### 余码表示法存储步骤【3步】：
1. 转换二进制
2. 转换数加上偏移量【二进制】
3. 补位

不过人类对于二进制处理并不是那么敏锐，我们人类进行存储推算是可以这样：
1. 原数加上偏移量【十进制】
2. 转换二进制
3. 补位 
这样存储的结果不变，不过对于人类来说更容易进行计算，这里的计算是十进制而非二进制，更方便计算。

示例：
```
注：以下偏移量均为127【1 111 111】

将十进制数6存储到 8位存储单元【计算机实际存储】：
1. 转换二进制： 110
2. 加上偏移量： 110+1111111=10000101
3. 补位： 10000101
4. 存储

将十进制数-36存储到 8位存储单元【人脑推算】：
1. 加上偏移量： -36+127=91
2. 转换二进制： 1011011
3. 补位： 01011011
4. 存储
```

#### IEEE标准
IEEE【电子和电器工程师协会】定义了几种存储浮点数的标准，使用的比较多的是单精度和双精度两种，下面介绍下。

##### 单精度
符号1位，指数8位【偏移量127】，尾数23位，共计32位

##### 双精度
符号1位，指数11位【偏移量1023】，尾数52位，共计64位

#### IEEE标准浮点数的存储步骤【5步】
> 以下S代表符号，E代表指数，M代表尾数
1. 找到符号S【0/1】
2. 数字转换为二进制
3. 规范化【科学计数法】
4. 指数E 【余码表示法】
5. 尾数M 【右侧补零】
6. 连接S、E、M
> 注意，存储特例0时这三个【S、E、M】约定都设置为0

```
十进制数5.75 的单精度存储
1. 符号： 0
2. 转二进制： 101.11
3. 规范化： 1.0111 * 2E2
4. 指数：2+127=129【十进制】=>10000001【二进制】
5. 尾数：0111=>01110000000000000000000【右边补零】
6. 连接：0 10000001 10110000000000000000000

十进制数-161.875的单精度存储
1. 符号： 1
2. 转二进制： 10100001.111
3. 规范化： 1.0100001111 * 2E7
4. 指数：7+127=134 => 10000110
5. 尾数：0100001111 => 01000011110000000000000
5. 连接：1 10000110 01000011110000000000000

十进制数-0.0234375的单精度存储
1. 符号： 1
2. 转二进制： 0.0000011
3. 规范化： 1.1 * 2E6
4. 指数：-6+127=121 => 01111001
5. 尾数：10000000000000000000000
5. 连接：1 01111001 10000000000000000000000
```

#### IEEE标准浮点数的还原步骤【5步】
1. 符号
2. 位移量【E-127】
3. 去规范
4. 转十进制
5. 连接符号与绝对值

```
将单精度数11 001 010 000 000 000 111 000 100 001 111还原：
1. 符号： 1=> 符号
2. 位移量： 10010100 - 127 = 148-121 = 21
3. 尾数去规范：1.00 000 000 111 000 100 001 111 * 2E21 = 100 000 000 111 000 100 001 1.11
4. 转十进制： 2104378.75
5. 连接： -2104378.75
```

#### 溢出处理
...待完善

#### 截断误差
浮点表示法存储实数可能存在误差，比如说需要存储的尾数由30位，单精度表示法只能存储左边的23位，右边的7位被截断了，还原后的数字会与原数值不同这种情况被称作截断误差。

某些情况下需要用到更精确的大数字或极小数字，为此IEEE定义了一些更大尾数的表示法，这里注意一下。

